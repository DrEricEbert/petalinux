diff --git a/drivers/clk/clk-axi-clkgen.c b/drivers/clk/clk-axi-clkgen.c
old mode 100644
new mode 100755
index 3294db3..ca2ce50
--- a/drivers/clk/clk-axi-clkgen.c
+++ b/drivers/clk/clk-axi-clkgen.c
@@ -16,8 +16,19 @@
 #include <linux/module.h>
 #include <linux/err.h>
 
+#define AXI_CLKGEN_V1_REG_UPDATE_ENABLE	0x04
+#define AXI_CLKGEN_V1_REG_CLK_OUT1	0x08
+#define AXI_CLKGEN_V1_REG_CLK_OUT2	0x0c
+#define AXI_CLKGEN_V1_REG_CLK_DIV	0x10
+#define AXI_CLKGEN_V1_REG_CLK_FB1	0x14
+#define AXI_CLKGEN_V1_REG_CLK_FB2	0x18
+#define AXI_CLKGEN_V1_REG_LOCK1		0x1c
+#define AXI_CLKGEN_V1_REG_LOCK2		0x20
+#define AXI_CLKGEN_V1_REG_LOCK3		0x24
+#define AXI_CLKGEN_V1_REG_FILTER1	0x28
+#define AXI_CLKGEN_V1_REG_FILTER2	0x2c
+
 #define AXI_CLKGEN_V2_REG_RESET		0x40
-#define AXI_CLKGEN_V2_REG_CLKSEL	0x44
 #define AXI_CLKGEN_V2_REG_DRP_CNTRL	0x70
 #define AXI_CLKGEN_V2_REG_DRP_STATUS	0x74
 
@@ -40,11 +51,41 @@
 #define MMCM_REG_FILTER1	0x4e
 #define MMCM_REG_FILTER2	0x4f
 
+struct axi_clkgen;
+
+struct axi_clkgen_mmcm_ops {
+	void (*enable)(struct axi_clkgen *axi_clkgen, bool enable);
+	int (*write)(struct axi_clkgen *axi_clkgen, unsigned int reg,
+		     unsigned int val, unsigned int mask);
+	int (*read)(struct axi_clkgen *axi_clkgen, unsigned int reg,
+		    unsigned int *val);
+};
+
 struct axi_clkgen {
 	void __iomem *base;
+	const struct axi_clkgen_mmcm_ops *mmcm_ops;
 	struct clk_hw clk_hw;
+	unsigned int fixed_clock_in;
 };
 
+static void axi_clkgen_mmcm_enable(struct axi_clkgen *axi_clkgen,
+	bool enable)
+{
+	axi_clkgen->mmcm_ops->enable(axi_clkgen, enable);
+}
+
+static int axi_clkgen_mmcm_write(struct axi_clkgen *axi_clkgen,
+	unsigned int reg, unsigned int val, unsigned int mask)
+{
+	return axi_clkgen->mmcm_ops->write(axi_clkgen, reg, val, mask);
+}
+
+static int axi_clkgen_mmcm_read(struct axi_clkgen *axi_clkgen,
+	unsigned int reg, unsigned int *val)
+{
+	return axi_clkgen->mmcm_ops->read(axi_clkgen, reg, val);
+}
+
 static uint32_t axi_clkgen_lookup_filter(unsigned int m)
 {
 	switch (m) {
@@ -167,6 +208,70 @@ static void axi_clkgen_read(struct axi_clkgen *axi_clkgen,
 	*val = readl(axi_clkgen->base + reg);
 }
 
+static unsigned int axi_clkgen_v1_map_mmcm_reg(unsigned int reg)
+{
+	switch (reg) {
+	case MMCM_REG_CLKOUT0_1:
+		return AXI_CLKGEN_V1_REG_CLK_OUT1;
+	case MMCM_REG_CLKOUT0_2:
+		return AXI_CLKGEN_V1_REG_CLK_OUT2;
+	case MMCM_REG_CLK_FB1:
+		return AXI_CLKGEN_V1_REG_CLK_FB1;
+	case MMCM_REG_CLK_FB2:
+		return AXI_CLKGEN_V1_REG_CLK_FB2;
+	case MMCM_REG_CLK_DIV:
+		return AXI_CLKGEN_V1_REG_CLK_DIV;
+	case MMCM_REG_LOCK1:
+		return AXI_CLKGEN_V1_REG_LOCK1;
+	case MMCM_REG_LOCK2:
+		return AXI_CLKGEN_V1_REG_LOCK2;
+	case MMCM_REG_LOCK3:
+		return AXI_CLKGEN_V1_REG_LOCK3;
+	case MMCM_REG_FILTER1:
+		return AXI_CLKGEN_V1_REG_FILTER1;
+	case MMCM_REG_FILTER2:
+		return AXI_CLKGEN_V1_REG_FILTER2;
+	default:
+		return 0;
+	}
+}
+
+static int axi_clkgen_v1_mmcm_write(struct axi_clkgen *axi_clkgen,
+	unsigned int reg, unsigned int val, unsigned int mask)
+{
+	reg = axi_clkgen_v1_map_mmcm_reg(reg);
+	if (reg == 0)
+		return -EINVAL;
+
+	axi_clkgen_write(axi_clkgen, reg, val);
+
+	return 0;
+}
+
+static int axi_clkgen_v1_mmcm_read(struct axi_clkgen *axi_clkgen,
+	unsigned int reg, unsigned int *val)
+{
+	reg = axi_clkgen_v1_map_mmcm_reg(reg);
+	if (reg == 0)
+		return -EINVAL;
+
+	axi_clkgen_read(axi_clkgen, reg, val);
+
+	return 0;
+}
+
+static void axi_clkgen_v1_mmcm_enable(struct axi_clkgen *axi_clkgen,
+	bool enable)
+{
+	axi_clkgen_write(axi_clkgen, AXI_CLKGEN_V1_REG_UPDATE_ENABLE, enable);
+}
+
+static const struct axi_clkgen_mmcm_ops axi_clkgen_v1_mmcm_ops = {
+	.write = axi_clkgen_v1_mmcm_write,
+	.read = axi_clkgen_v1_mmcm_read,
+	.enable = axi_clkgen_v1_mmcm_enable,
+};
+
 static int axi_clkgen_wait_non_busy(struct axi_clkgen *axi_clkgen)
 {
 	unsigned int timeout = 10000;
@@ -182,7 +287,7 @@ static int axi_clkgen_wait_non_busy(struct axi_clkgen *axi_clkgen)
 	return val & 0xffff;
 }
 
-static int axi_clkgen_mmcm_read(struct axi_clkgen *axi_clkgen,
+static int axi_clkgen_v2_mmcm_read(struct axi_clkgen *axi_clkgen,
 	unsigned int reg, unsigned int *val)
 {
 	unsigned int reg_val;
@@ -206,7 +311,7 @@ static int axi_clkgen_mmcm_read(struct axi_clkgen *axi_clkgen,
 	return 0;
 }
 
-static int axi_clkgen_mmcm_write(struct axi_clkgen *axi_clkgen,
+static int axi_clkgen_v2_mmcm_write(struct axi_clkgen *axi_clkgen,
 	unsigned int reg, unsigned int val, unsigned int mask)
 {
 	unsigned int reg_val = 0;
@@ -217,7 +322,7 @@ static int axi_clkgen_mmcm_write(struct axi_clkgen *axi_clkgen,
 		return ret;
 
 	if (mask != 0xffff) {
-		axi_clkgen_mmcm_read(axi_clkgen, reg, &reg_val);
+		axi_clkgen_v2_mmcm_read(axi_clkgen, reg, &reg_val);
 		reg_val &= ~mask;
 	}
 
@@ -228,7 +333,7 @@ static int axi_clkgen_mmcm_write(struct axi_clkgen *axi_clkgen,
 	return 0;
 }
 
-static void axi_clkgen_mmcm_enable(struct axi_clkgen *axi_clkgen,
+static void axi_clkgen_v2_mmcm_enable(struct axi_clkgen *axi_clkgen,
 	bool enable)
 {
 	unsigned int val = AXI_CLKGEN_V2_RESET_ENABLE;
@@ -239,6 +344,12 @@ static void axi_clkgen_mmcm_enable(struct axi_clkgen *axi_clkgen,
 	axi_clkgen_write(axi_clkgen, AXI_CLKGEN_V2_REG_RESET, val);
 }
 
+static const struct axi_clkgen_mmcm_ops axi_clkgen_v2_mmcm_ops = {
+	.write = axi_clkgen_v2_mmcm_write,
+	.read = axi_clkgen_v2_mmcm_read,
+	.enable = axi_clkgen_v2_mmcm_enable,
+};
+
 static struct axi_clkgen *clk_hw_to_axi_clkgen(struct clk_hw *clk_hw)
 {
 	return container_of(clk_hw, struct axi_clkgen, clk_hw);
@@ -256,6 +367,8 @@ static int axi_clkgen_set_rate(struct clk_hw *clk_hw,
 	uint32_t filter;
 	uint32_t lock;
 
+	parent_rate = axi_clkgen->fixed_clock_in;
+
 	if (parent_rate == 0 || rate == 0)
 		return -EINVAL;
 
@@ -297,14 +410,15 @@ static int axi_clkgen_set_rate(struct clk_hw *clk_hw,
 static long axi_clkgen_round_rate(struct clk_hw *hw, unsigned long rate,
 	unsigned long *parent_rate)
 {
+	struct axi_clkgen *axi_clkgen = clk_hw_to_axi_clkgen(hw);
 	unsigned int d, m, dout;
 
-	axi_clkgen_calc_params(*parent_rate, rate, &d, &m, &dout);
+	axi_clkgen_calc_params(axi_clkgen->fixed_clock_in, rate, &d, &m, &dout);
 
 	if (d == 0 || dout == 0 || m == 0)
 		return -EINVAL;
 
-	return *parent_rate / d * m / dout;
+	return axi_clkgen->fixed_clock_in / d * m / dout;
 }
 
 static unsigned long axi_clkgen_recalc_rate(struct clk_hw *clk_hw,
@@ -325,10 +439,13 @@ static unsigned long axi_clkgen_recalc_rate(struct clk_hw *clk_hw,
 	if (d == 0 || dout == 0)
 		return 0;
 
-	tmp = (unsigned long long)(parent_rate / d) * m;
+	tmp = (unsigned long long)(axi_clkgen->fixed_clock_in / d) * m;
 	do_div(tmp, dout);
 
-	return min_t(unsigned long long, tmp, ULONG_MAX);
+	if (tmp > ULONG_MAX)
+		return ULONG_MAX;
+
+	return tmp;
 }
 
 static int axi_clkgen_enable(struct clk_hw *clk_hw)
@@ -347,38 +464,21 @@ static void axi_clkgen_disable(struct clk_hw *clk_hw)
 	axi_clkgen_mmcm_enable(axi_clkgen, false);
 }
 
-static int axi_clkgen_set_parent(struct clk_hw *clk_hw, u8 index)
-{
-	struct axi_clkgen *axi_clkgen = clk_hw_to_axi_clkgen(clk_hw);
-
-	axi_clkgen_write(axi_clkgen, AXI_CLKGEN_V2_REG_CLKSEL, index);
-
-	return 0;
-}
-
-static u8 axi_clkgen_get_parent(struct clk_hw *clk_hw)
-{
-	struct axi_clkgen *axi_clkgen = clk_hw_to_axi_clkgen(clk_hw);
-	unsigned int parent;
-
-	axi_clkgen_read(axi_clkgen, AXI_CLKGEN_V2_REG_CLKSEL, &parent);
-
-	return parent;
-}
-
 static const struct clk_ops axi_clkgen_ops = {
 	.recalc_rate = axi_clkgen_recalc_rate,
 	.round_rate = axi_clkgen_round_rate,
 	.set_rate = axi_clkgen_set_rate,
 	.enable = axi_clkgen_enable,
 	.disable = axi_clkgen_disable,
-	.set_parent = axi_clkgen_set_parent,
-	.get_parent = axi_clkgen_get_parent,
 };
 
 static const struct of_device_id axi_clkgen_ids[] = {
 	{
+		.compatible = "adi,axi-clkgen-1.00.a",
+		.data = &axi_clkgen_v1_mmcm_ops
+	}, {
 		.compatible = "adi,axi-clkgen-2.00.a",
+		.data = &axi_clkgen_v2_mmcm_ops,
 	},
 	{ },
 };
@@ -389,10 +489,9 @@ static int axi_clkgen_probe(struct platform_device *pdev)
 	const struct of_device_id *id;
 	struct axi_clkgen *axi_clkgen;
 	struct clk_init_data init;
-	const char *parent_names[2];
 	const char *clk_name;
 	struct resource *mem;
-	unsigned int i;
+	unsigned int fixed_clock_in;
 	int ret;
 
 	if (!pdev->dev.of_node)
@@ -406,20 +505,21 @@ static int axi_clkgen_probe(struct platform_device *pdev)
 	if (!axi_clkgen)
 		return -ENOMEM;
 
+	axi_clkgen->mmcm_ops = id->data;
+
 	mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	axi_clkgen->base = devm_ioremap_resource(&pdev->dev, mem);
 	if (IS_ERR(axi_clkgen->base))
 		return PTR_ERR(axi_clkgen->base);
 
-	init.num_parents = of_clk_get_parent_count(pdev->dev.of_node);
-	if (init.num_parents < 1 || init.num_parents > 2)
-		return -EINVAL;
-
-	for (i = 0; i < init.num_parents; i++) {
-		parent_names[i] = of_clk_get_parent_name(pdev->dev.of_node, i);
-		if (!parent_names[i])
-			return -EINVAL;
+	err = of_property_read_u32(pdev->dev.of_node, "fixed-clock-in",
+			&fixed_clock_in);
+	if (err) {
+		dev_err(&pdev->dev, "'fixed-clock-in' property missing\n");
+		return err;
 	}
+	axi_clkgen->fixed_clock_in = fixed_clock_in;
+	
 
 	clk_name = pdev->dev.of_node->name;
 	of_property_read_string(pdev->dev.of_node, "clock-output-names",
@@ -427,8 +527,8 @@ static int axi_clkgen_probe(struct platform_device *pdev)
 
 	init.name = clk_name;
 	init.ops = &axi_clkgen_ops;
-	init.flags = CLK_SET_RATE_GATE | CLK_SET_PARENT_GATE;
-	init.parent_names = parent_names;
+	init.flags = CLK_IS_ROOT;
+	init.num_parents = 0;
 
 	axi_clkgen_mmcm_enable(axi_clkgen, false);
 
diff --git a/drivers/gpu/drm/xilinx/xilinx_drm_drv.c b/drivers/gpu/drm/xilinx/xilinx_drm_drv.c
old mode 100644
new mode 100755
index 9af14a91..bfd3748
--- a/drivers/gpu/drm/xilinx/xilinx_drm_drv.c
+++ b/drivers/gpu/drm/xilinx/xilinx_drm_drv.c
@@ -78,8 +78,8 @@ struct xilinx_video_format_desc {
 static const struct xilinx_video_format_desc xilinx_video_formats[] = {
 	{ "yuv420", 16, 16, XILINX_VIDEO_FORMAT_YUV420, DRM_FORMAT_YUV420 },
 	{ "uvy422", 16, 16, XILINX_VIDEO_FORMAT_NONE, DRM_FORMAT_UYVY },
-	{ "vuy422", 16, 16, XILINX_VIDEO_FORMAT_YUV422, DRM_FORMAT_VYUY },
 	{ "yuv422", 16, 16, XILINX_VIDEO_FORMAT_YUV422, DRM_FORMAT_YUYV },
+	{ "vuy422", 16, 16, XILINX_VIDEO_FORMAT_YUV422, DRM_FORMAT_VYUY },
 	{ "yvu422", 16, 16, XILINX_VIDEO_FORMAT_NONE, DRM_FORMAT_YVYU },
 	{ "yuv444", 24, 24, XILINX_VIDEO_FORMAT_YUV444, DRM_FORMAT_YUV444 },
 	{ "nv12", 16, 16, XILINX_VIDEO_FORMAT_NONE, DRM_FORMAT_NV12 },
diff --git a/drivers/gpu/drm/xilinx/xilinx_drm_plane.c b/drivers/gpu/drm/xilinx/xilinx_drm_plane.c
old mode 100644
new mode 100755
index 2646763..7a76325
--- a/drivers/gpu/drm/xilinx/xilinx_drm_plane.c
+++ b/drivers/gpu/drm/xilinx/xilinx_drm_plane.c
@@ -801,7 +801,7 @@ xilinx_drm_plane_create(struct xilinx_drm_plane_manager *manager,
 	}
 
 	/* probe color space converter */
-	sub_node = of_parse_phandle(plane_node, "xlnx,rgb2yuv", i);
+	sub_node = of_parse_phandle(plane_node, "xlnx,rgb2yuv", 0);
 	if (sub_node) {
 		plane->rgb2yuv = xilinx_rgb2yuv_probe(dev, sub_node);
 		of_node_put(sub_node);
@@ -819,7 +819,7 @@ xilinx_drm_plane_create(struct xilinx_drm_plane_manager *manager,
 	}
 
 	/* probe chroma resampler */
-	sub_node = of_parse_phandle(plane_node, "xlnx,cresample", i);
+	sub_node = of_parse_phandle(plane_node, "xlnx,cresample", 0);
 	if (sub_node) {
 		plane->cresample = xilinx_cresample_probe(dev, sub_node);
 		of_node_put(sub_node);
diff --git a/drivers/media/i2c/Kconfig b/drivers/media/i2c/Kconfig
old mode 100644
new mode 100755
index 993dc50..d643da5
--- a/drivers/media/i2c/Kconfig
+++ b/drivers/media/i2c/Kconfig
@@ -585,6 +585,14 @@ config VIDEO_MT9M111
 	  This driver supports MT9M111, MT9M112 and MT9M131 cameras from
 	  Micron/Aptina
 
+config VIDEO_MT9M114
+	tristate "MT9M114 camera sensor support"
+	depends on I2C && VIDEO_V4L2 && VIDEO_V4L2_SUBDEV_API
+	depends on MEDIA_CAMERA_SUPPORT
+	---help---
+	  This driver supports MT9M114 camera sensors from ON-Semi
+	  models only.	  	  
+	  
 config VIDEO_MT9P031
 	tristate "Aptina MT9P031 support"
 	depends on I2C && VIDEO_V4L2 && VIDEO_V4L2_SUBDEV_API
diff --git a/drivers/media/i2c/Makefile b/drivers/media/i2c/Makefile
old mode 100644
new mode 100755
index 94f2c99..8f0168b
--- a/drivers/media/i2c/Makefile
+++ b/drivers/media/i2c/Makefile
@@ -61,6 +61,7 @@ obj-$(CONFIG_VIDEO_OV7640) += ov7640.o
 obj-$(CONFIG_VIDEO_OV9650) += ov9650.o
 obj-$(CONFIG_VIDEO_MT9M032) += mt9m032.o
 obj-$(CONFIG_VIDEO_MT9M111) += mt9m111.o
+obj-$(CONFIG_VIDEO_MT9M114) += mt9m114.o
 obj-$(CONFIG_VIDEO_MT9P031) += mt9p031.o
 obj-$(CONFIG_VIDEO_MT9T001) += mt9t001.o
 obj-$(CONFIG_VIDEO_MT9V011) += mt9v011.o
diff --git a/drivers/media/i2c/mt9m114.c b/drivers/media/i2c/mt9m114.c
new file mode 100755
index 0000000..9992a61
--- /dev/null
+++ b/drivers/media/i2c/mt9m114.c
@@ -0,0 +1,1281 @@
+/*
+ * mt9m114.c Aptina MT9M114 sensor driver
+ *
+ * refer to: SoC Camera driver by Scott Jiang <Scott.Jiang.Linux@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+#define DEBUG
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/i2c.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+#include <linux/videodev2.h>
+
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-mediabus.h>
+#include <media/media-entity.h>
+#include <dt-bindings/media/xilinx-vip.h>
+
+#define DRIVER_NAME		"mt9m114"
+
+/* Sysctl registers */
+#define MT9M114_CHIP_ID								0x0000
+#define MT9M114_COMMAND_REGISTER					0x0080
+#define MT9M114_COMMAND_REGISTER_APPLY_PATCH		(1 << 0)
+#define MT9M114_COMMAND_REGISTER_SET_STATE			(1 << 1)
+#define MT9M114_COMMAND_REGISTER_REFRESH			(1 << 2)
+#define MT9M114_COMMAND_REGISTER_WAIT_FOR_EVENT		(1 << 3)
+#define MT9M114_COMMAND_REGISTER_OK					(1 << 15)
+#define MT9M114_SOFT_RESET							0x001a
+#define MT9M114_PAD_SLEW							0x001e
+#define MT9M114_PAD_CONTROL							0x0032
+
+/* XDMA registers */
+#define MT9M114_ACCESS_CTL_STAT						0x0982
+#define MT9M114_PHYSICAL_ADDRESS_ACCESS				0x098a
+#define MT9M114_LOGICAL_ADDRESS_ACCESS				0x098e
+		
+/* Core registers */		
+#define MT9M114_RESET_REGISTER						0x301a
+#define MT9M114_FLASH								0x3046
+#define MT9M114_CUSTOMER_REV						0x31fe
+
+/* Camera Control registers */
+#define MT9M114_CAM_SENSOR_CFG_Y_ADDR_START			0xc800
+#define MT9M114_CAM_SENSOR_CFG_X_ADDR_START			0xc802
+#define MT9M114_CAM_SENSOR_CFG_Y_ADDR_END			0xc804
+#define MT9M114_CAM_SENSOR_CFG_X_ADDR_END			0xc806
+#define MT9M114_CAM_SENSOR_CFG_PIXCLK				0xc808
+#define MT9M114_CAM_SENSOR_CFG_ROW_SPEED			0xc80c
+#define MT9M114_CAM_SENSOR_CFG_FINE_INTEG_TIME_MIN	0xc80e
+#define MT9M114_CAM_SENSOR_CFG_FINE_INTEG_TIME_MAX	0xc810
+#define MT9M114_CAM_SENSOR_CFG_FRAME_LENGTH_LINES	0xc812
+#define MT9M114_CAM_SENSOR_CFG_LINE_LENGTH_PCK		0xc814
+#define MT9M114_CAM_SENSOR_CFG_FINE_CORRECTION		0xc816
+#define MT9M114_CAM_SENSOR_CFG_CPIPE_LAST_ROW		0xc818
+#define MT9M114_CAM_SENSOR_CFG_REG_0_DATA			0xc826
+#define MT9M114_CAM_SENSOR_CONTROL_READ_MODE		0xc834
+#define MT9M114_CAM_CROP_WINDOW_XOFFSET				0xc854
+#define MT9M114_CAM_CROP_WINDOW_YOFFSET				0xc856
+#define MT9M114_CAM_CROP_WINDOW_WIDTH				0xc858
+#define MT9M114_CAM_CROP_WINDOW_HEIGHT				0xc85a
+#define MT9M114_CAM_CROP_CROPMODE					0xc85c
+#define MT9M114_CAM_OUTPUT_WIDTH					0xc868
+#define MT9M114_CAM_OUTPUT_HEIGHT					0xc86a
+#define MT9M114_CAM_OUTPUT_FORMAT					0xc86c
+#define MT9M114_CAM_AET_AEMODE						0xc878
+#define MT9M114_CAM_AET_MAX_FRAME_RATE				0xc88c
+#define MT9M114_CAM_AET_MIN_FRAME_RATE				0xc88e
+#define MT9M114_CAM_AWB_AWB_XSCALE					0xc8f2
+#define MT9M114_CAM_AWB_AWB_YSCALE					0xc8f3
+#define MT9M114_CAM_AWB_AWB_XSHIFT_PRE_ADJ			0xc904
+#define MT9M114_CAM_AWB_AWB_YSHIFT_PRE_ADJ			0xc906
+#define MT9M114_CAM_STAT_AWB_CLIP_WINDOW_XSTART		0xc914
+#define MT9M114_CAM_STAT_AWB_CLIP_WINDOW_YSTART		0xc916
+#define MT9M114_CAM_STAT_AWB_CLIP_WINDOW_XEND		0xc918
+#define MT9M114_CAM_STAT_AWB_CLIP_WINDOW_YEND		0xc91a
+#define MT9M114_CAM_STAT_AE_INITIAL_WINDOW_XSTART	0xc91c
+#define MT9M114_CAM_STAT_AE_INITIAL_WINDOW_YSTART	0xc91e
+#define MT9M114_CAM_STAT_AE_INITIAL_WINDOW_XEND		0xc920
+#define MT9M114_CAM_STAT_AE_INITIAL_WINDOW_YEND		0xc922
+#define MT9M114_CAM_SYSCTL_PLL_ENABLE				0xc97e
+#define MT9M114_CAM_SYSCTL_PLL_DIVIDER_M_N			0xc980
+#define MT9M114_CAM_SYSCTL_PLL_DIVIDER_P			0xc982
+#define MT9M114_CAM_PORT_OUTPUT_CONTROL				0xc984
+
+/* System Manager registers */
+#define MT9M114_SYSMGR_NEXT_STATE					0xdc00
+#define MT9M114_SYSMGR_CURRENT_STATE				0xdc01
+#define MT9M114_SYSMGR_CMD_STATUS					0xdc02
+		
+/* Patch Loader registers */		
+#define MT9M114_PATCHLDR_LOADER_ADDRESS				0xe000
+#define MT9M114_PATCHLDR_PATCH_ID					0xe002
+#define MT9M114_PATCHLDR_FIRMWARE_ID				0xe004
+#define MT9M114_PATCHLDR_APPLY_STATUS				0xe008
+#define MT9M114_PATCHLDR_NUM_PATCHES				0xe009
+#define MT9M114_PATCHLDR_PATCH_ID_0					0xe00a
+#define MT9M114_PATCHLDR_PATCH_ID_1					0xe00c
+#define MT9M114_PATCHLDR_PATCH_ID_2					0xe00e
+#define MT9M114_PATCHLDR_PATCH_ID_3					0xe010
+#define MT9M114_PATCHLDR_PATCH_ID_4					0xe012
+#define MT9M114_PATCHLDR_PATCH_ID_5					0xe014
+#define MT9M114_PATCHLDR_PATCH_ID_6					0xe016
+#define MT9M114_PATCHLDR_PATCH_ID_7					0xe018
+
+/* SYS_STATE values (for SYSMGR_NEXT_STATE and SYSMGR_CURRENT_STATE) */
+#define MT9M114_SYS_STATE_ENTER_CONFIG_CHANGE		0x28
+#define MT9M114_SYS_STATE_STREAMING					0x31
+#define MT9M114_SYS_STATE_START_STREAMING			0x34
+#define MT9M114_SYS_STATE_ENTER_SUSPEND				0x40
+#define MT9M114_SYS_STATE_SUSPENDED					0x41
+#define MT9M114_SYS_STATE_ENTER_STANDBY				0x50
+#define MT9M114_SYS_STATE_STANDBY					0x52
+#define MT9M114_SYS_STATE_LEAVE_STANDBY				0x54
+	
+/* Result status of last SET_STATE comamnd */	
+#define MT9M114_SET_STATE_RESULT_ENOERR				0x00
+#define MT9M114_SET_STATE_RESULT_EINVAL				0x0c
+#define MT9M114_SET_STATE_RESULT_ENOSPC				0x0d
+
+#define MAX_FRAME_RATE 30
+
+enum {
+	SOURCE_PAD,
+	NUM_PADS
+};
+
+struct mt9m114_video_format {
+	unsigned int vf_code;
+	unsigned int width;
+	const char *pattern;
+	unsigned int mbus_code;
+	unsigned int bpp;
+	u32 fourcc;
+	const char *description;
+	enum v4l2_colorspace colorspace;
+};
+
+struct mt9m114_reg {
+	u16 reg;
+	u32 val;
+	int width;
+};
+
+enum {
+	MT9M114_QVGA,
+	MT9M114_VGA,
+	MT9M114_WVGA,
+	MT9M114_720P,
+};
+
+struct mt9m114_resolution {
+	unsigned int width;
+	unsigned int height;
+};
+
+#ifdef DEBUG
+static bool debug = 1;
+#else
+static bool debug = 0;
+#endif
+
+struct mt9m114 {
+	struct v4l2_subdev sd;
+	struct v4l2_ctrl_handler hdl;
+	struct v4l2_fract frame_rate;
+	struct media_pad pads[NUM_PADS];
+	unsigned int npads;
+	struct v4l2_mbus_framefmt formats[NUM_PADS];
+	struct v4l2_mbus_framefmt default_format;
+	const struct mt9m114_video_format *vid_format;
+	struct mt9m114_resolution cur_fs;
+};
+
+static const struct mt9m114_video_format mt9m114_supported_video_formats[] = {
+	{ XVIP_VF_MONO_SENSOR, 	8, "rggb", 	MEDIA_BUS_FMT_SRGGB8_1X8, 	1, V4L2_PIX_FMT_SRGGB8, "Bayer 8-bit RGGB", 	V4L2_COLORSPACE_SRGB },
+	{ XVIP_VF_MONO_SENSOR, 	8, "grbg", 	MEDIA_BUS_FMT_SGRBG8_1X8, 	1, V4L2_PIX_FMT_SGRBG8, "Bayer 8-bit GRBG", 	V4L2_COLORSPACE_SRGB },
+	{ XVIP_VF_MONO_SENSOR, 	8, "gbrg", 	MEDIA_BUS_FMT_SGBRG8_1X8, 	1, V4L2_PIX_FMT_SGBRG8, "Bayer 8-bit GBRG", 	V4L2_COLORSPACE_SRGB },
+	{ XVIP_VF_MONO_SENSOR, 	8, "bggr", 	MEDIA_BUS_FMT_SBGGR8_1X8, 	1, V4L2_PIX_FMT_SBGGR8, "Bayer 8-bit BGGR", 	V4L2_COLORSPACE_SRGB },
+};
+
+static const struct mt9m114_resolution mt9m114_resolutions[] = {
+	[MT9M114_QVGA] = {
+		.width  = 320,
+		.height = 240,
+	},
+	[MT9M114_VGA] = {
+		.width  = 640,
+		.height = 480,
+	},
+	[MT9M114_WVGA] = {
+		.width  = 800,
+		.height = 480,
+	},
+	[MT9M114_720P] = {
+		.width  = 1280,
+		.height = 720,
+	},
+};
+
+static const struct mt9m114_reg mt9m114_init[] = {
+	{ MT9M114_RESET_REGISTER,                        0x0218, 2 },
+
+	/* PLL settings */
+	{ MT9M114_LOGICAL_ADDRESS_ACCESS,                0x0000, 2 },
+	{ MT9M114_CAM_SYSCTL_PLL_ENABLE,                 0x01,   1 },
+	{ MT9M114_CAM_SYSCTL_PLL_DIVIDER_M_N,            0x0120, 2 },
+	{ MT9M114_CAM_SYSCTL_PLL_DIVIDER_P,              0x0700, 2 },
+	{ MT9M114_CAM_SENSOR_CFG_PIXCLK,                 0x2DC6C00, 4 },
+
+	/* Sensor optimization */
+	{ 0x316A, 0x8270, 2 },
+	{ 0x316C, 0x8270, 2 },
+	{ 0x3ED0, 0x2305, 2 },
+	{ 0x3ED2, 0x77CF, 2 },
+	{ 0x316E, 0x8202, 2 },
+	{ 0x3180, 0x87FF, 2 },
+	{ 0x30D4, 0x6080, 2 },
+	{ 0xA802, 0x0008, 2 },
+	{ 0x3E14, 0xFF39, 2 },
+
+	/* APGA */
+	{ 0xC95E, 0x0000, 2 },
+
+	/* Camera control module   */
+	{ 0xC892, 0x0267, 2 },
+	{ 0xC894, 0xFF1A, 2 },
+	{ 0xC896, 0xFFB3, 2 },
+	{ 0xC898, 0xFF80, 2 },
+	{ 0xC89A, 0x0166, 2 },
+	{ 0xC89C, 0x0003, 2 },
+	{ 0xC89E, 0xFF9A, 2 },
+	{ 0xC8A0, 0xFEB4, 2 },
+	{ 0xC8A2, 0x024D, 2 },
+	{ 0xC8A4, 0x01BF, 2 },
+	{ 0xC8A6, 0xFF01, 2 },
+	{ 0xC8A8, 0xFFF3, 2 },
+	{ 0xC8AA, 0xFF75, 2 },
+	{ 0xC8AC, 0x0198, 2 },
+	{ 0xC8AE, 0xFFFD, 2 },
+	{ 0xC8B0, 0xFF9A, 2 },
+	{ 0xC8B2, 0xFEE7, 2 },
+	{ 0xC8B4, 0x02A8, 2 },
+	{ 0xC8B6, 0x01D9, 2 },
+	{ 0xC8B8, 0xFF26, 2 },
+	{ 0xC8BA, 0xFFF3, 2 },
+	{ 0xC8BC, 0xFFB3, 2 },
+	{ 0xC8BE, 0x0132, 2 },
+	{ 0xC8C0, 0xFFE8, 2 },
+	{ 0xC8C2, 0xFFDA, 2 },
+	{ 0xC8C4, 0xFECD, 2 },
+	{ 0xC8C6, 0x02C2, 2 },
+	{ 0xC8C8, 0x0075, 2 },
+	{ 0xC8CA, 0x011C, 2 },
+	{ 0xC8CC, 0x009A, 2 },
+	{ 0xC8CE, 0x0105, 2 },
+	{ 0xC8D0, 0x00A4, 2 },
+	{ 0xC8D2, 0x00AC, 2 },
+	{ 0xC8D4, 0x0A8C, 2 },
+	{ 0xC8D6, 0x0F0A, 2 },
+	{ 0xC8D8, 0x1964, 2 },
+
+	/* Automatic White balance */
+	{ MT9M114_CAM_AWB_AWB_XSHIFT_PRE_ADJ,            0x0033, 2 },
+	{ MT9M114_CAM_AWB_AWB_YSHIFT_PRE_ADJ,            0x003C, 2 },
+	{ MT9M114_CAM_AWB_AWB_XSCALE,                    0x03,   1 },
+	{ MT9M114_CAM_AWB_AWB_YSCALE,                    0x02,   1 },
+	{ 0xC8F4, 0x0000, 2 },
+	{ 0xC8F6, 0x0000, 2 },
+	{ 0xC8F8, 0x0000, 2 },
+	{ 0xC8FA, 0xE724, 2 },
+	{ 0xC8FC, 0x1583, 2 },
+	{ 0xC8FE, 0x2045, 2 },
+	{ 0xC900, 0x03FF, 2 },
+	{ 0xC902, 0x007C, 2 },
+	{ 0xC90C, 0x80,   1 },
+	{ 0xC90D, 0x80,   1 },
+	{ 0xC90E, 0x80,   1 },
+	{ 0xC90F, 0x88,   1 },
+	{ 0xC910, 0x80,   1 },
+	{ 0xC911, 0x80,   1 },
+
+	/* CPIPE Preference */
+	{ 0xC926, 0x0020, 2 },
+	{ 0xC928, 0x009A, 2 },
+	{ 0xC946, 0x0070, 2 },
+	{ 0xC948, 0x00F3, 2 },
+	{ 0xC944, 0x20,   1 },
+	{ 0xC945, 0x9A,   1 },
+	{ 0xC92A, 0x80,   1 },
+	{ 0xC92B, 0x4B,   1 },
+	{ 0xC92C, 0x00,   1 },
+	{ 0xC92D, 0xFF,   1 },
+	{ 0xC92E, 0x3C,   1 },
+	{ 0xC92F, 0x02,   1 },
+	{ 0xC930, 0x06,   1 },
+	{ 0xC931, 0x64,   1 },
+	{ 0xC932, 0x01,   1 },
+	{ 0xC933, 0x0C,   1 },
+	{ 0xC934, 0x3C,   1 },
+	{ 0xC935, 0x3C,   1 },
+	{ 0xC936, 0x3C,   1 },
+	{ 0xC937, 0x0F,   1 },
+	{ 0xC938, 0x64,   1 },
+	{ 0xC939, 0x64,   1 },
+	{ 0xC93A, 0x64,   1 },
+	{ 0xC93B, 0x32,   1 },
+	{ 0xC93C, 0x0020, 2 },
+	{ 0xC93E, 0x009A, 2 },
+	{ 0xC940, 0x00DC, 2 },
+	{ 0xC942, 0x38,   1 },
+	{ 0xC943, 0x30,   1 },
+	{ 0xC944, 0x50,   1 },
+	{ 0xC945, 0x19,   1 },
+	{ 0xC94A, 0x0230, 2 },
+	{ 0xC94C, 0x0010, 2 },
+	{ 0xC94E, 0x01CD, 2 },
+	{ 0xC950, 0x05,   1 },
+	{ 0xC951, 0x40,   1 },
+	{ 0xC87B, 0x1B,   1 },
+	{ MT9M114_CAM_AET_AEMODE, 0x0E, 1 },
+	{ 0xC890, 0x0080, 2 },
+	{ 0xC886, 0x0100, 2 },
+	{ 0xC87C, 0x005A, 2 },
+	{ 0xB42A, 0x05,   1 },
+	{ 0xA80A, 0x20,   1 },
+
+	{ MT9M114_LOGICAL_ADDRESS_ACCESS,                0x0000, 2 },
+	{ MT9M114_CAM_PORT_OUTPUT_CONTROL,               0x8040, 2 }, // 0xC984 
+	{ MT9M114_PAD_SLEW,                              0x0777, 2 },
+};
+
+static const struct mt9m114_reg mt9m114_regs_qvga[] = { // 320x240
+	{ MT9M114_LOGICAL_ADDRESS_ACCESS,                0x1000, 2 },
+	{ MT9M114_CAM_SENSOR_CFG_Y_ADDR_START,           0x0000, 2 },
+	{ MT9M114_CAM_SENSOR_CFG_X_ADDR_START,           0x0000, 2 },
+	{ MT9M114_CAM_SENSOR_CFG_Y_ADDR_END,             0x03CD, 2 },
+	{ MT9M114_CAM_SENSOR_CFG_X_ADDR_END,             0x050D, 2 },
+	{ MT9M114_CAM_SENSOR_CFG_ROW_SPEED,              0x0001, 2 },
+	{ MT9M114_CAM_SENSOR_CFG_FINE_INTEG_TIME_MIN,    0x01C3, 2 },
+	{ MT9M114_CAM_SENSOR_CFG_FINE_INTEG_TIME_MAX,    0x03F7, 2 },
+	{ MT9M114_CAM_SENSOR_CFG_FRAME_LENGTH_LINES,     0x0500, 2 },
+	{ MT9M114_CAM_SENSOR_CFG_LINE_LENGTH_PCK,        0x04E2, 2 },
+	{ MT9M114_CAM_SENSOR_CFG_FINE_CORRECTION,        0x00E0, 2 },
+	{ MT9M114_CAM_SENSOR_CFG_CPIPE_LAST_ROW,         0x01E3, 2 },
+	{ MT9M114_CAM_SENSOR_CFG_REG_0_DATA,             0x0020, 2 },
+	{ MT9M114_CAM_CROP_WINDOW_XOFFSET,               0x0000, 2 },
+	{ MT9M114_CAM_CROP_WINDOW_YOFFSET,               0x0000, 2 },
+	{ MT9M114_CAM_CROP_WINDOW_WIDTH,                 0x0280, 2 }, // 640
+	{ MT9M114_CAM_CROP_WINDOW_HEIGHT,                0x01E0, 2 }, // 480
+	{ MT9M114_CAM_CROP_CROPMODE,                     0x03,   1 },
+	{ MT9M114_CAM_OUTPUT_WIDTH,                      0x0140, 2 }, // 320
+	{ MT9M114_CAM_OUTPUT_HEIGHT,                     0x00F0, 2 }, // 240
+	{ MT9M114_CAM_AET_AEMODE,                        0x00,   1 },
+	{ MT9M114_CAM_STAT_AWB_CLIP_WINDOW_XSTART,       0x0000, 2 },
+	{ MT9M114_CAM_STAT_AWB_CLIP_WINDOW_YSTART,       0x0000, 2 },
+	{ MT9M114_CAM_STAT_AWB_CLIP_WINDOW_XEND,         0x013F, 2 },
+	{ MT9M114_CAM_STAT_AWB_CLIP_WINDOW_YEND,         0x00EF, 2 },
+	{ MT9M114_CAM_STAT_AE_INITIAL_WINDOW_XSTART,     0x0000, 2 },
+	{ MT9M114_CAM_STAT_AE_INITIAL_WINDOW_YSTART,     0x0000, 2 },
+	{ MT9M114_CAM_STAT_AE_INITIAL_WINDOW_XEND,       0x003F, 2 },
+	{ MT9M114_CAM_STAT_AE_INITIAL_WINDOW_YEND,       0x002F, 2 },
+};
+
+static const struct mt9m114_reg mt9m114_regs_vga[] = { // 640x480
+	{ MT9M114_LOGICAL_ADDRESS_ACCESS,                0x1000, 2 },
+	{ MT9M114_CAM_SENSOR_CFG_Y_ADDR_START,           0x0000, 2 },
+	{ MT9M114_CAM_SENSOR_CFG_X_ADDR_START,           0x0000, 2 },
+	{ MT9M114_CAM_SENSOR_CFG_Y_ADDR_END,             0x03CD, 2 },
+	{ MT9M114_CAM_SENSOR_CFG_X_ADDR_END,             0x050D, 2 },
+	{ MT9M114_CAM_SENSOR_CFG_ROW_SPEED,              0x0001, 2 },
+	{ MT9M114_CAM_SENSOR_CFG_FINE_INTEG_TIME_MIN,    0x01C3, 2 },
+	{ MT9M114_CAM_SENSOR_CFG_FINE_INTEG_TIME_MAX,    0x03F7, 2 },
+	{ MT9M114_CAM_SENSOR_CFG_FRAME_LENGTH_LINES,     0x0500, 2 },
+	{ MT9M114_CAM_SENSOR_CFG_LINE_LENGTH_PCK,        0x04E2, 2 },
+	{ MT9M114_CAM_SENSOR_CFG_FINE_CORRECTION,        0x00E0, 2 },
+	{ MT9M114_CAM_SENSOR_CFG_CPIPE_LAST_ROW,         0x01E3, 2 },
+	{ MT9M114_CAM_SENSOR_CFG_REG_0_DATA,             0x0020, 2 },
+	{ MT9M114_CAM_CROP_WINDOW_XOFFSET,               0x0000, 2 },
+	{ MT9M114_CAM_CROP_WINDOW_YOFFSET,               0x0000, 2 },
+	{ MT9M114_CAM_CROP_WINDOW_WIDTH,                 0x0280, 2 }, // 640 
+	{ MT9M114_CAM_CROP_WINDOW_HEIGHT,                0x01E0, 2 }, // 480
+	{ MT9M114_CAM_CROP_CROPMODE,                     0x03,   1 }, 
+	{ MT9M114_CAM_OUTPUT_WIDTH,                      0x0280, 2 }, // 640
+	{ MT9M114_CAM_OUTPUT_HEIGHT,                     0x01E0, 2 }, // 480
+	{ MT9M114_CAM_AET_AEMODE,                        0x00,   1 },
+	{ MT9M114_CAM_STAT_AWB_CLIP_WINDOW_XSTART,       0x0000, 2 },
+	{ MT9M114_CAM_STAT_AWB_CLIP_WINDOW_YSTART,       0x0000, 2 },
+	{ MT9M114_CAM_STAT_AWB_CLIP_WINDOW_XEND,         0x027F, 2 },
+	{ MT9M114_CAM_STAT_AWB_CLIP_WINDOW_YEND,         0x01DF, 2 },
+	{ MT9M114_CAM_STAT_AE_INITIAL_WINDOW_XSTART,     0x0000, 2 },
+	{ MT9M114_CAM_STAT_AE_INITIAL_WINDOW_YSTART,     0x0000, 2 },
+	{ MT9M114_CAM_STAT_AE_INITIAL_WINDOW_XEND,       0x007F, 2 },
+	{ MT9M114_CAM_STAT_AE_INITIAL_WINDOW_YEND,       0x005F, 2 },
+};
+
+static const struct mt9m114_reg mt9m114_regs_wvga[] = { // 800x480
+	{ MT9M114_LOGICAL_ADDRESS_ACCESS,                0x1000, 2 },
+	{ MT9M114_CAM_SENSOR_CFG_Y_ADDR_START,           0x00F4, 2 },
+	{ MT9M114_CAM_SENSOR_CFG_X_ADDR_START,           0x00F4, 2 },
+	{ MT9M114_CAM_SENSOR_CFG_Y_ADDR_END,             0x02DB, 2 },
+	{ MT9M114_CAM_SENSOR_CFG_X_ADDR_END,             0x041B, 2 },
+	{ MT9M114_CAM_SENSOR_CFG_ROW_SPEED,              0x0001, 2 },
+	{ MT9M114_CAM_SENSOR_CFG_FINE_INTEG_TIME_MIN,    0x00DB, 2 },
+	{ MT9M114_CAM_SENSOR_CFG_FINE_INTEG_TIME_MAX,    0x045F, 2 },
+	{ MT9M114_CAM_SENSOR_CFG_FRAME_LENGTH_LINES,     0x0500, 2 },
+	{ MT9M114_CAM_SENSOR_CFG_LINE_LENGTH_PCK,        0x04E2, 2 },
+	{ MT9M114_CAM_SENSOR_CFG_FINE_CORRECTION,        0x0060, 2 },
+	{ MT9M114_CAM_SENSOR_CFG_CPIPE_LAST_ROW,         0x01E3, 2 },
+	{ MT9M114_CAM_SENSOR_CFG_REG_0_DATA,             0x0020, 2 },
+	{ MT9M114_CAM_CROP_WINDOW_XOFFSET,               0x0000, 2 },
+	{ MT9M114_CAM_CROP_WINDOW_YOFFSET,               0x0000, 2 },
+	{ MT9M114_CAM_CROP_WINDOW_WIDTH,                 0x0320, 2 }, // 800
+	{ MT9M114_CAM_CROP_WINDOW_HEIGHT,                0x01E0, 2 }, // 480
+	{ MT9M114_CAM_CROP_CROPMODE,                     0x03,   1 },
+	{ MT9M114_CAM_OUTPUT_WIDTH,                      0x0320, 2 }, // 800
+	{ MT9M114_CAM_OUTPUT_HEIGHT,                     0x01E0, 2 }, // 480
+	{ MT9M114_CAM_AET_AEMODE,                        0x00,   1 },
+	{ MT9M114_CAM_STAT_AWB_CLIP_WINDOW_XSTART,       0x0000, 2 },
+	{ MT9M114_CAM_STAT_AWB_CLIP_WINDOW_YSTART,       0x0000, 2 },
+	{ MT9M114_CAM_STAT_AWB_CLIP_WINDOW_XEND,         0x031F, 2 },
+	{ MT9M114_CAM_STAT_AWB_CLIP_WINDOW_YEND,         0x01DF, 2 },
+	{ MT9M114_CAM_STAT_AE_INITIAL_WINDOW_XSTART,     0x0000, 2 },
+	{ MT9M114_CAM_STAT_AE_INITIAL_WINDOW_YSTART,     0x0000, 2 },
+	{ MT9M114_CAM_STAT_AE_INITIAL_WINDOW_XEND,       0x009F, 2 },
+	{ MT9M114_CAM_STAT_AE_INITIAL_WINDOW_YEND,       0x005F, 2 },
+};
+
+static const struct mt9m114_reg mt9m114_regs_720p[] = { // 1280x720
+	{ MT9M114_LOGICAL_ADDRESS_ACCESS,                0x1000, 2 	},
+	{ MT9M114_CAM_SENSOR_CFG_Y_ADDR_START,           124, 2 	}, // 0xC800 	(1st row of visible data), 0x007C
+	{ MT9M114_CAM_SENSOR_CFG_X_ADDR_START,           4, 2 		}, // 0xC802
+	{ MT9M114_CAM_SENSOR_CFG_Y_ADDR_END,             851, 2 	}, // 0xC804 	(last row of visible data), 0x0335
+	{ MT9M114_CAM_SENSOR_CFG_X_ADDR_END,             1291, 2 	}, // 0xC806, 	0x50B
+	{ MT9M114_CAM_SENSOR_CFG_ROW_SPEED,              0x0001, 2 	},
+	{ MT9M114_CAM_SENSOR_CFG_FINE_INTEG_TIME_MIN,    219, 2 	}, // 			0x00DB
+	{ MT9M114_CAM_SENSOR_CFG_FINE_INTEG_TIME_MAX,    1558, 2 	}, // 			0x0616
+	{ MT9M114_CAM_SENSOR_CFG_FRAME_LENGTH_LINES,     778, 2 	}, // 0xC812 	(visible + vbank lines), 0x030A
+	{ MT9M114_CAM_SENSOR_CFG_LINE_LENGTH_PCK,        1689, 2	}, // 			0x0699
+	{ MT9M114_CAM_SENSOR_CFG_FINE_CORRECTION,        96, 2 		}, // 			0x0060
+	{ MT9M114_CAM_SENSOR_CFG_CPIPE_LAST_ROW,         723, 2 	}, // 0xC818,	0x02D3
+	{ MT9M114_CAM_SENSOR_CFG_REG_0_DATA,             0x0020, 2 	},
+	{ MT9M114_CAM_CROP_WINDOW_XOFFSET,               0x0000, 2 	}, // 0xC854
+	{ MT9M114_CAM_CROP_WINDOW_YOFFSET,               0x0000, 2 	}, // 0xC856
+	{ MT9M114_CAM_CROP_WINDOW_WIDTH,                 1280, 2 	}, // 0xC858,	0x0500
+	{ MT9M114_CAM_CROP_WINDOW_HEIGHT,                720, 2 	}, // 0xC85A,	0x02D0
+	{ MT9M114_CAM_CROP_CROPMODE,                     0x03,   1 	},
+	{ MT9M114_CAM_OUTPUT_WIDTH,                      1280, 2 	}, // 0xC868,	0x0500
+	{ MT9M114_CAM_OUTPUT_HEIGHT,                     720, 2 	}, // 0xC86A,	0x02D0
+	{ MT9M114_CAM_AET_AEMODE,                        0x00,   1 	},
+	{ MT9M114_CAM_STAT_AWB_CLIP_WINDOW_XSTART,       0x0000, 2 	},
+	{ MT9M114_CAM_STAT_AWB_CLIP_WINDOW_YSTART,       0x0000, 2 	},
+	{ MT9M114_CAM_STAT_AWB_CLIP_WINDOW_XEND,         1279, 2 	}, //			0x04FF
+	{ MT9M114_CAM_STAT_AWB_CLIP_WINDOW_YEND,         719, 2 	}, //			0x02CF
+	{ MT9M114_CAM_STAT_AE_INITIAL_WINDOW_XSTART,     0x0000, 2 	},
+	{ MT9M114_CAM_STAT_AE_INITIAL_WINDOW_YSTART,     0x0000, 2 	},
+	{ MT9M114_CAM_STAT_AE_INITIAL_WINDOW_XEND,       255, 2 	},
+	{ MT9M114_CAM_STAT_AE_INITIAL_WINDOW_YEND,       143, 2 	},
+};
+
+static inline struct mt9m114 *to_mt9m114(struct v4l2_subdev *sd)
+{
+	return container_of(sd, struct mt9m114, sd);
+}
+static inline struct v4l2_subdev *to_sd(struct v4l2_ctrl *ctrl)
+{
+	return &container_of(ctrl->handler, struct mt9m114, hdl)->sd;
+}
+
+static int mt9m114_write8(struct i2c_client *client, u16 reg, u8 val)
+{
+	int ret;
+	struct {
+		u16 reg;
+		u8 val;
+	} __packed buf;
+	struct i2c_msg msg = {
+		.addr   = client->addr,
+		.flags  = 0,
+		.len    = 3,
+		.buf    = (u8 *)&buf,
+	};
+	buf.reg = swab16(reg);
+	buf.val = val;
+
+	ret = i2c_transfer(client->adapter, &msg, 1);
+	if (ret < 0) {
+		v4l_err(client, "Failed to write register 0x%04x!\n", reg);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int mt9m114_read16(struct i2c_client *client, u16 reg, u16 *val)
+{
+	int ret;
+	u16 rval;
+	struct i2c_msg msg[] = {
+		{
+			.addr   = client->addr,
+			.flags  = 0,
+			.len    = 2,
+			.buf    = (u8 *)&reg,
+		},
+		{
+			.addr   = client->addr,
+			.flags  = I2C_M_RD,
+			.len    = 2,
+			.buf    = (u8 *)&rval,
+		},
+	};
+
+	reg = swab16(reg);
+
+	ret = i2c_transfer(client->adapter, msg, 2);
+	if (ret < 0) {
+		v4l_err(client, "Failed to read register 0x%04x!\n", reg);
+		return ret;
+	}
+	*val = swab16(rval);
+
+	return 0;
+}
+
+static int mt9m114_write16(struct i2c_client *client, u16 reg, u16 val)
+{
+	int ret;
+	struct {
+		u16 reg;
+		u16 val;
+	} __packed buf;
+	struct i2c_msg msg = {
+		.addr   = client->addr,
+		.flags  = 0,
+		.len    = 4,
+		.buf    = (u8 *)&buf,
+	};
+	buf.reg = swab16(reg);
+	buf.val = swab16(val);
+
+	ret = i2c_transfer(client->adapter, &msg, 1);
+	if (ret < 0) {
+		v4l_err(client, "Failed to write register 0x%04x!\n", reg);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int mt9m114_write32(struct i2c_client *client, u16 reg, u32 val)
+{
+	int ret;
+	struct {
+		u16 reg;
+		u32 val;
+	} __packed buf;
+	struct i2c_msg msg = {
+		.addr   = client->addr,
+		.flags  = 0,
+		.len    = 6,
+		.buf    = (u8 *)&buf,
+	};
+	buf.reg = swab16(reg);
+	buf.val = swab32(val);
+
+	ret = i2c_transfer(client->adapter, &msg, 1);
+	if (ret < 0) {
+		v4l_err(client, "Failed to write register 0x%04x!\n", reg);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int mt9m114_writeregs(struct i2c_client *client,
+		const struct mt9m114_reg *regs, int len)
+{
+	int i, ret;
+
+	for (i = 0; i < len; i++) {
+		switch (regs[i].width) {
+		case 1:
+			ret = mt9m114_write8(client,
+					regs[i].reg, regs[i].val);
+			break;
+		case 2:
+			ret = mt9m114_write16(client,
+					regs[i].reg, regs[i].val);
+			break;
+		case 4:
+			ret = mt9m114_write32(client,
+					regs[i].reg, regs[i].val);
+			break;
+		default:
+			ret = -EINVAL;
+			break;
+		}
+		if (ret < 0)
+			return ret;
+	}
+	return 0;
+}
+
+static void mt9m114_res_roundup(u32 *width, u32 *height)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(mt9m114_resolutions); i++)
+		if ((mt9m114_resolutions[i].width >= *width) &&
+				(mt9m114_resolutions[i].height >= *height)) {
+			*width = mt9m114_resolutions[i].width;
+			*height = mt9m114_resolutions[i].height;
+			return;
+		}
+	*width = mt9m114_resolutions[MT9M114_720P].width;
+	*height = mt9m114_resolutions[MT9M114_720P].height;
+}
+
+static int mt9m114_set_res(struct i2c_client *client, u32 width, u32 height)
+{
+	u16 read_mode;
+
+	if ((width == mt9m114_resolutions[MT9M114_QVGA].width)
+		&& (height == mt9m114_resolutions[MT9M114_QVGA].height)) {
+		mt9m114_writeregs(client, mt9m114_regs_qvga,
+				ARRAY_SIZE(mt9m114_regs_qvga));
+		mt9m114_read16(client,
+			MT9M114_CAM_SENSOR_CONTROL_READ_MODE, &read_mode);
+		read_mode = (read_mode & 0xfccf) | 0x0330;
+		mt9m114_write16(client,
+			MT9M114_CAM_SENSOR_CONTROL_READ_MODE, read_mode);
+	} else if ((width == mt9m114_resolutions[MT9M114_VGA].width)
+		&& (height == mt9m114_resolutions[MT9M114_VGA].height)) {
+		mt9m114_writeregs(client, mt9m114_regs_vga,
+				ARRAY_SIZE(mt9m114_regs_vga));
+		mt9m114_read16(client,
+			MT9M114_CAM_SENSOR_CONTROL_READ_MODE, &read_mode);
+		read_mode = (read_mode & 0xfccf) | 0x0330;
+		mt9m114_write16(client,
+			MT9M114_CAM_SENSOR_CONTROL_READ_MODE, read_mode);
+	} else if ((width == mt9m114_resolutions[MT9M114_WVGA].width)
+		&& (height == mt9m114_resolutions[MT9M114_WVGA].height)) {
+		mt9m114_writeregs(client, mt9m114_regs_wvga,
+				ARRAY_SIZE(mt9m114_regs_wvga));
+		mt9m114_read16(client,
+			MT9M114_CAM_SENSOR_CONTROL_READ_MODE, &read_mode);
+		read_mode &= 0xfccf;
+		mt9m114_write16(client,
+			MT9M114_CAM_SENSOR_CONTROL_READ_MODE, read_mode);
+	} else if ((width == mt9m114_resolutions[MT9M114_720P].width)
+		&& (height == mt9m114_resolutions[MT9M114_720P].height)) {
+		mt9m114_writeregs(client, mt9m114_regs_720p,
+				ARRAY_SIZE(mt9m114_regs_720p));
+		mt9m114_read16(client,
+			MT9M114_CAM_SENSOR_CONTROL_READ_MODE, &read_mode);
+		read_mode &= 0xfccf;
+		mt9m114_write16(client,
+			MT9M114_CAM_SENSOR_CONTROL_READ_MODE, read_mode);
+	} else {
+		v4l_err(client, "Failed to select resolution!\n");
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int mt9m114_set_state(struct i2c_client *client, u8 next_state)
+{
+	int timeout = 100, ret;
+	u16 command;
+
+	/* set the next desired state */
+	ret = mt9m114_write8(client, MT9M114_SYSMGR_NEXT_STATE, next_state);
+	if (ret < 0)
+		return ret;
+
+	/* start state transition */
+	ret = mt9m114_write16(client, MT9M114_COMMAND_REGISTER,
+			(MT9M114_COMMAND_REGISTER_OK
+			 | MT9M114_COMMAND_REGISTER_SET_STATE));
+	if (ret < 0)
+		return ret;
+
+	/* wait for the state transition to complete */
+	while (timeout) {
+		ret = mt9m114_read16(client,
+				MT9M114_COMMAND_REGISTER, &command);
+		if (ret < 0)
+			return ret;
+		if (!(command & MT9M114_COMMAND_REGISTER_SET_STATE))
+			break;
+		msleep(10);
+		timeout--;
+	}
+	if (!timeout) {
+		v4l_err(client, "Failed to poll command register\n");
+		return -ETIMEDOUT;
+	}
+
+	/* check if the command is successful */
+	ret = mt9m114_read16(client,
+			MT9M114_COMMAND_REGISTER, &command);
+	if (ret < 0)
+		return ret;
+	if (command & MT9M114_COMMAND_REGISTER_OK)
+		return 0;
+	else
+		return -EFAULT;
+}
+
+static int mt9m114_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct v4l2_subdev *sd = to_sd(ctrl);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	switch (ctrl->id) {
+	case V4L2_CID_HFLIP:
+	{
+		u16 read_mode;
+		mt9m114_read16(client,
+			MT9M114_CAM_SENSOR_CONTROL_READ_MODE, &read_mode);
+		read_mode = (read_mode & 0xfffe) | ctrl->val;
+		mt9m114_write16(client,
+			MT9M114_CAM_SENSOR_CONTROL_READ_MODE, read_mode);
+		break;
+	}
+	case V4L2_CID_VFLIP:
+	{
+		u16 read_mode;
+		mt9m114_read16(client,
+			MT9M114_CAM_SENSOR_CONTROL_READ_MODE, &read_mode);
+		read_mode = (read_mode & 0xfffd) | (ctrl->val << 1);
+		mt9m114_write16(client,
+			MT9M114_CAM_SENSOR_CONTROL_READ_MODE, read_mode);
+		break;
+	}
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int mt9m114_g_parm(struct v4l2_subdev *sd,
+				struct v4l2_streamparm *parms)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct v4l2_captureparm *cp = &parms->parm.capture;
+	u16 frame_rate;
+
+	if (parms->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+		return -EINVAL;
+
+	memset(cp, 0, sizeof(*cp));
+	cp->capability = V4L2_CAP_TIMEPERFRAME;
+	cp->timeperframe.numerator = 1;
+	mt9m114_read16(client, MT9M114_CAM_AET_MAX_FRAME_RATE, &frame_rate);
+	cp->timeperframe.denominator = frame_rate >> 8;
+	return 0;
+}
+
+static int mt9m114_s_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *parms)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct v4l2_captureparm *cp = &parms->parm.capture;
+	struct v4l2_fract *tpf = &cp->timeperframe;
+	u16 frame_rate;
+
+	if (parms->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+		return -EINVAL;
+	if (cp->extendedmode != 0)
+		return -EINVAL;
+
+	if (tpf->numerator == 0 || tpf->denominator == 0
+		|| (tpf->denominator > tpf->numerator * MAX_FRAME_RATE)) {
+		/* reset to max frame rate */
+		tpf->numerator = 1;
+		tpf->denominator = MAX_FRAME_RATE;
+	}
+	frame_rate = (tpf->denominator / tpf->numerator) << 8;
+	mt9m114_write16(client, MT9M114_CAM_AET_MAX_FRAME_RATE, frame_rate);
+	mt9m114_write16(client, MT9M114_CAM_AET_MIN_FRAME_RATE, frame_rate);
+	return 0;
+}
+
+int mt9m114_g_frame_interval(struct v4l2_subdev *sd, struct v4l2_subdev_frame_interval *interval)
+{
+	// TODO: Add code
+	printk("%s : Code not implemented\n", __func__);
+	return 0;
+}
+
+int mt9m114_s_frame_interval(struct v4l2_subdev *sd, struct v4l2_subdev_frame_interval *interval)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct v4l2_fract *tpf = &interval->interval;
+	u16 frame_rate;
+	
+	if (tpf->numerator == 0 || tpf->denominator == 0
+		|| (tpf->denominator > tpf->numerator * MAX_FRAME_RATE)) {
+		/* reset to max frame rate */
+		tpf->numerator = 1;
+		tpf->denominator = MAX_FRAME_RATE;
+	}
+	frame_rate = (tpf->denominator / tpf->numerator) << 8;
+	mt9m114_write16(client, MT9M114_CAM_AET_MAX_FRAME_RATE, frame_rate);
+	mt9m114_write16(client, MT9M114_CAM_AET_MIN_FRAME_RATE, frame_rate);
+	return 0;
+}
+
+static int mt9m114_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+	ret = mt9m114_set_state(client,
+			MT9M114_SYS_STATE_ENTER_CONFIG_CHANGE);
+	if (ret < 0)
+		return ret;
+	if (enable)
+		ret = mt9m114_set_state(client,
+				MT9M114_SYS_STATE_START_STREAMING);
+	else
+		ret = mt9m114_set_state(client,
+				MT9M114_SYS_STATE_ENTER_SUSPEND);
+	return ret;
+}
+
+static const struct v4l2_ctrl_ops mt9m114_ctrl_ops = {
+	.s_ctrl = mt9m114_s_ctrl,
+};
+
+/* -----------------------------------------------------------------------------
+ * V4L2 Subdevice Pad Operations
+ */
+ 
+static struct v4l2_mbus_framefmt *
+__mt9m114_get_pad_format(	struct mt9m114 *sensor, 
+							struct v4l2_subdev_pad_config *cfg,
+							unsigned int pad, 
+							u32 which)
+{
+	if (pad >= sensor->npads)
+		return NULL;
+
+	switch (which) {
+		case V4L2_SUBDEV_FORMAT_TRY:
+			return v4l2_subdev_get_try_format(&sensor->sd, cfg, pad);
+		case V4L2_SUBDEV_FORMAT_ACTIVE:
+			return &sensor->formats[pad];
+		default:
+			return NULL;
+	}
+}
+
+static int mt9m114_try_mbus_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *fmt)
+{
+	int index;
+
+	for (index = 0; index < ARRAY_SIZE(mt9m114_supported_video_formats); index++){
+		if (mt9m114_supported_video_formats[index].mbus_code == fmt->code)
+			break;
+	}		
+			
+	if (index >= ARRAY_SIZE(mt9m114_supported_video_formats)) {
+		/* default to first format */
+		index = 0;
+		fmt->code = mt9m114_supported_video_formats[0].mbus_code;
+	}
+	mt9m114_res_roundup(&fmt->width, &fmt->height);
+
+	fmt->field = V4L2_FIELD_NONE;
+	fmt->colorspace = mt9m114_supported_video_formats[index].colorspace;
+	return 0;
+}
+
+static int mt9m114_s_mbus_fmt(	struct v4l2_subdev *sd,
+								struct v4l2_subdev_pad_config *cfg,
+								struct v4l2_subdev_format *fmt)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct mt9m114 *sensor = to_mt9m114(sd);
+	struct v4l2_mbus_framefmt *fmt_ptr;
+	struct v4l2_mbus_framefmt resp_fmt;
+	u16 output_fmt;
+	int ret;
+	
+	v4l2_dbg(1, debug, sd, "Set format\n");
+	fmt_ptr = __mt9m114_get_pad_format(sensor, cfg, fmt->pad, fmt->which);
+	if (fmt->pad >= sensor->npads || fmt_ptr == NULL)
+		return -EINVAL;
+
+	resp_fmt = fmt->format;
+	mt9m114_try_mbus_fmt(sd, &resp_fmt);
+
+	/* set image size */
+	ret = mt9m114_set_res(client, resp_fmt.width, resp_fmt.height);
+	if (ret < 0)
+		return ret;
+
+	/* set image format */
+	ret = mt9m114_read16(client, MT9M114_CAM_OUTPUT_FORMAT, &output_fmt);
+	if (ret < 0){
+		return ret;
+	}
+
+	output_fmt &= 0xc0fc;
+	switch (resp_fmt.code) {
+		case MEDIA_BUS_FMT_SGRBG8_1X8:
+		case MEDIA_BUS_FMT_SRGGB8_1X8:
+		case MEDIA_BUS_FMT_SGBRG8_1X8:
+		case MEDIA_BUS_FMT_SBGGR8_1X8:
+			output_fmt = 0x0200; // Bayer + Raw Bayer 10
+			break;
+		case MEDIA_BUS_FMT_YUYV8_2X8:
+			output_fmt |= 0x0002;
+			break;
+		case MEDIA_BUS_FMT_RGB565_2X8_LE:
+			output_fmt |= 0x0102;
+			break;
+		case MEDIA_BUS_FMT_RGB565_2X8_BE:
+			output_fmt |= 0x0100;
+			break;
+		default:
+			return -EINVAL;
+	}
+	ret = mt9m114_write16(client, MT9M114_CAM_OUTPUT_FORMAT, output_fmt);
+	if (ret < 0)
+		return ret;
+
+	// update try/active format
+	*fmt_ptr = resp_fmt;
+	fmt->format = resp_fmt; // response
+	return 0;
+}
+
+static int mt9m114_g_mbus_fmt(	struct v4l2_subdev *sd,
+								struct v4l2_subdev_pad_config *cfg,
+								struct v4l2_subdev_format *fmt)
+{
+	struct v4l2_mbus_framefmt *tfmt;
+	struct mt9m114 *sensor = to_mt9m114(sd);
+
+	v4l2_dbg(1, debug, sd, "Get format\n");
+	tfmt = __mt9m114_get_pad_format(sensor, cfg, fmt->pad, fmt->which);
+	if(tfmt == NULL){
+		return -EINVAL;
+	}
+	fmt->format = *tfmt;
+	
+	v4l2_dbg(1, debug, sd, "width       %d\n", tfmt->width);
+	v4l2_dbg(1, debug, sd, "height      %d\n", tfmt->height);
+	v4l2_dbg(1, debug, sd, "code        %d (0x%x)\n", tfmt->code, tfmt->code);
+	v4l2_dbg(1, debug, sd, "field       %d (0x%x)\n", tfmt->field, tfmt->field);
+	v4l2_dbg(1, debug, sd, "colorspace  %d (0x%x)\n", tfmt->colorspace, tfmt->colorspace);
+
+	return 0;
+}
+
+/* -----------------------------------------------------------------------------
+ * V4L2 Subdevice Operations
+ */
+ 
+static int mt9m114_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
+{
+	struct mt9m114 *mt9m114 = to_mt9m114(sd);
+	struct v4l2_mbus_framefmt *format;
+	/* Initialize with default formats */
+	// Use source pad format
+	format = v4l2_subdev_get_try_format(sd, fh->pad, 0);
+	*format = mt9m114->default_format;
+
+	return 0;
+}
+
+static int mt9m114_close(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
+{
+	return 0;
+}
+
+static const struct v4l2_subdev_internal_ops mt9m114_internal_ops = {
+	.open		= mt9m114_open,
+	.close		= mt9m114_close,
+}; 
+
+static const struct v4l2_subdev_pad_ops mt9m114_pad_ops = {
+	.get_fmt		= mt9m114_g_mbus_fmt,
+	.set_fmt		= mt9m114_s_mbus_fmt,
+};
+
+static const struct v4l2_subdev_video_ops mt9m114_video_ops = {
+	.s_parm = mt9m114_s_parm,
+	.g_parm = mt9m114_g_parm,
+	.g_frame_interval = mt9m114_g_frame_interval,
+	.s_frame_interval = mt9m114_s_frame_interval,
+	.s_stream = mt9m114_s_stream,
+};
+
+static const struct v4l2_subdev_ops mt9m114_ops = {
+	.pad	= &mt9m114_pad_ops,
+	.video 	= &mt9m114_video_ops,
+};
+
+/* -----------------------------------------------------------------------------
+ * Media Operations
+ */
+
+static const struct media_entity_operations mt9m114_media_ops = {
+	.link_validate = v4l2_subdev_link_validate,
+};
+
+/* -----------------------------------------------------------------------------
+ * Platform Device Driver
+ */
+
+static const struct mt9m114_video_format *mt9m114_parse_video_format(struct device_node *node)
+{
+	const char *pattern = "mono";
+	unsigned int vf_code;
+	unsigned int i;
+	u32 width;
+	int ret;
+
+	ret = of_property_read_u32(node, "xlnx,video-format", &vf_code);
+	if (ret < 0)
+		return ERR_PTR(ret);
+
+	ret = of_property_read_u32(node, "xlnx,video-width", &width);
+	if (ret < 0)
+		return ERR_PTR(ret);
+
+	if (vf_code == XVIP_VF_MONO_SENSOR)
+		of_property_read_string(node, "xlnx,cfa-pattern", &pattern);
+
+	for (i = 0; i < ARRAY_SIZE(mt9m114_supported_video_formats); ++i) {
+		const struct mt9m114_video_format *format = &mt9m114_supported_video_formats[i];
+
+		if (format->vf_code != vf_code || format->width != width)
+			continue;
+
+		if (vf_code == XVIP_VF_MONO_SENSOR &&
+		    strcmp(pattern, format->pattern))
+			continue;
+
+		return format;
+	}
+
+	return ERR_PTR(-EINVAL);
+}
+
+static int mt9m114_parse_dt(struct v4l2_subdev *sd)
+{
+	struct mt9m114 *sensor = to_mt9m114(sd); 
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct device_node *node = client->dev.of_node;
+	struct device_node *ports;
+	struct device_node *port;
+	unsigned int nports = 0;
+	int ep_num = 0;
+
+	if (!node) {
+		return -EINVAL;
+	}
+
+	ports = of_get_child_by_name(node, "ports");
+	if (ports == NULL)
+		ports = node;
+
+	for_each_child_of_node(ports, port) {
+		const struct mt9m114_video_format *format;
+		struct device_node *endpoint;
+
+		if (!port->name || of_node_cmp(port->name, "port"))
+			continue;
+
+		format = mt9m114_parse_video_format(port);
+		if (IS_ERR(format)) {
+			v4l_err(client, "invalid format in DT");
+			return PTR_ERR(format);
+		}
+
+		/* Get and check the format description */
+		if (!sensor->vid_format) {
+			sensor->vid_format = format;
+		} else {
+			v4l_err(client, "Support single pad only");
+			return -EINVAL;
+		}
+
+		endpoint = of_get_next_child(port, NULL);
+		if (endpoint){
+			ep_num++;
+			of_node_put(endpoint);
+		}
+
+		/* Count the number of ports. */
+		nports++;
+	}
+
+	if (nports != 1 && ep_num != 1) {
+		v4l_err(client, "invalid number of ports %u / endpoints %d\n", nports, ep_num);
+		return -EINVAL;
+	}
+
+	sensor->npads = nports;
+
+	return 0;
+}
+
+static int mt9m114_probe(struct i2c_client *client,
+			const struct i2c_device_id *id)
+{
+	struct mt9m114 *sensor;
+	struct v4l2_subdev *sd;
+	struct v4l2_ctrl_handler *hdl;
+	u16 chip_id, command, output_control;
+	//struct v4l2_mbus_framefmt default_fmt;
+	int ret;
+
+	/* Check if the adapter supports the needed features */
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C))
+		return -EIO;
+		
+	ret = mt9m114_read16(client, MT9M114_CHIP_ID, &chip_id);
+	if (ret < 0) {
+		v4l_err(client, "Failed to get chip id\n");
+		return -ENODEV;
+	}
+	
+	if (chip_id != 0x2481) {
+		v4l_err(client, "chip id 0x%04x mismatch\n", chip_id);
+		return -ENODEV;
+	}
+	
+	/* Reset the sensor */
+	ret = mt9m114_write16(client, MT9M114_SOFT_RESET, 0x0001);
+	if (ret < 0) {
+		v4l_err(client, "Failed to reset the sensor\n");
+		return ret;
+	}
+	mt9m114_write16(client, MT9M114_SOFT_RESET, 0x0000);
+	mdelay(50);
+
+	do {
+		ret = mt9m114_read16(client, MT9M114_COMMAND_REGISTER, &command);
+		if (ret < 0)
+			return ret;
+	} while (command & MT9M114_COMMAND_REGISTER_SET_STATE);
+	
+	ret = mt9m114_writeregs(client, mt9m114_init, ARRAY_SIZE(mt9m114_init));
+	if (ret < 0) {
+		v4l_err(client, "Failed to initialize the sensor\n");
+		return ret;
+	}
+
+	/* Set the sensor in parallel data output mode */
+	mt9m114_read16(client, MT9M114_CAM_PORT_OUTPUT_CONTROL, &output_control);
+	output_control &= 0xfff8;
+	mt9m114_write16(client, MT9M114_CAM_PORT_OUTPUT_CONTROL, output_control);
+	mt9m114_set_state(client, MT9M114_SYS_STATE_ENTER_CONFIG_CHANGE);
+
+	sensor = kzalloc(sizeof(*sensor), GFP_KERNEL);
+	if (sensor == NULL)
+		return -ENOMEM;
+
+	v4l_info(client, "chip found @ 0x%02x (%s)\n", client->addr << 1, client->adapter->name);
+	v4l_info(client, "got to blah");
+	
+	/* Initialize V4L2 subdevice */
+	sd = &sensor->sd;
+	v4l2_i2c_subdev_init(sd, client, &mt9m114_ops);	
+	
+	/* Parse dt */
+	if(mt9m114_parse_dt(sd) < 0){
+		ret = -EFAULT;
+		goto err1;
+	}
+	
+	/* Initialize V4L2 subdevice and media entity
+	 * Should only have SOURCE pad
+	 */
+	sensor->pads[SOURCE_PAD].flags = MEDIA_PAD_FL_SOURCE;
+
+	/* Initialize the default format */
+	sensor->default_format.code = sensor->vid_format->mbus_code;
+	sensor->default_format.field = V4L2_FIELD_NONE;
+	sensor->default_format.colorspace = V4L2_COLORSPACE_SRGB;
+	sensor->default_format.width = mt9m114_resolutions[MT9M114_720P].width;
+	sensor->default_format.height = mt9m114_resolutions[MT9M114_720P].height;
+	sensor->formats[SOURCE_PAD] = sensor->default_format;
+	
+	/* Initialize V4L2 media entity */
+	strcpy(sd->name, DRIVER_NAME); // Will use this name in the video pipeline driver
+	sd->internal_ops = &mt9m114_internal_ops;
+	sd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+	sd->entity.ops = &mt9m114_media_ops;
+	ret = media_entity_pads_init(&sd->entity, sensor->npads, sensor->pads);
+	if (ret < 0){
+		goto err1;
+	}
+	
+	/*
+	 * Initialize hardware controls
+	 */
+	hdl = &sensor->hdl;
+	v4l2_ctrl_handler_init(hdl, 2);
+	v4l2_ctrl_new_std(hdl, &mt9m114_ctrl_ops, V4L2_CID_HFLIP, 0, 1, 1, 0);
+	v4l2_ctrl_new_std(hdl, &mt9m114_ctrl_ops, V4L2_CID_VFLIP, 0, 1, 1, 0);
+	/* hook the control handler into the driver */
+	sd->ctrl_handler = hdl;
+	if (hdl->error) {
+		ret = hdl->error;
+		goto err2;
+	}
+	ret = v4l2_ctrl_handler_setup(hdl);
+	if (ret) {
+		goto err2;
+	}
+	ret = v4l2_async_register_subdev(sd);
+	if (ret < 0){
+		goto err2;
+	}
+
+	return 0;
+
+err2:
+	v4l2_ctrl_handler_free(hdl);
+	media_entity_cleanup(&sd->entity);
+err1:
+	kfree(sensor);
+	return ret;
+}
+
+static int mt9m114_remove(struct i2c_client *client)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct mt9m114 *sensor = to_mt9m114(sd);
+
+	v4l2_device_unregister_subdev(sd);
+	v4l2_ctrl_handler_free(sd->ctrl_handler);
+	kfree(sensor);
+	return 0;
+}
+
+static const struct i2c_device_id mt9m114_id[] = {
+	{DRIVER_NAME, 0},
+	{},
+};
+
+MODULE_DEVICE_TABLE(i2c, mt9m114_id);
+
+static struct i2c_driver mt9m114_driver = {
+	.driver = {
+		.owner  = THIS_MODULE,
+		.name   = DRIVER_NAME,
+	},
+	.probe          = mt9m114_probe,
+	.remove         = mt9m114_remove,
+	.id_table       = mt9m114_id,
+};
+
+module_i2c_driver(mt9m114_driver);
+
+MODULE_DESCRIPTION("Aptina MT9M114 sensor driver");
+MODULE_AUTHOR("Watson Chow <watson.chow@avnet.com>");
+MODULE_LICENSE("GPL v2");
\ No newline at end of file
