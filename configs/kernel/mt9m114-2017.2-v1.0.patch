diff --git a/drivers/media/i2c/Kconfig b/drivers/media/i2c/Kconfig
old mode 100644
new mode 100755
index 2669b4b..054710a
--- a/drivers/media/i2c/Kconfig
+++ b/drivers/media/i2c/Kconfig
@@ -585,6 +585,13 @@ config VIDEO_MT9M111
 	  This driver supports MT9M111, MT9M112 and MT9M131 cameras from
 	  Micron/Aptina
 
+config VIDEO_MT9M114
+	tristate "mt9m114 support"
+	depends on I2C && VIDEO_V4L2
+	help
+	  This driver supports MT9M114 cameras from
+	  Micron/Aptina	  
+
 config VIDEO_MT9P031
 	tristate "Aptina MT9P031 support"
 	depends on I2C && VIDEO_V4L2 && VIDEO_V4L2_SUBDEV_API
diff --git a/drivers/media/i2c/Makefile b/drivers/media/i2c/Makefile
old mode 100644
new mode 100755
index 92773b2..77bbc87
--- a/drivers/media/i2c/Makefile
+++ b/drivers/media/i2c/Makefile
@@ -65,6 +65,7 @@ obj-$(CONFIG_VIDEO_MT9P031) += mt9p031.o
 obj-$(CONFIG_VIDEO_MT9T001) += mt9t001.o
 obj-$(CONFIG_VIDEO_MT9V011) += mt9v011.o
 obj-$(CONFIG_VIDEO_MT9V032) += mt9v032.o
+obj-$(CONFIG_VIDEO_MT9M114) += mt9m114.o
 obj-$(CONFIG_VIDEO_SR030PC30)	+= sr030pc30.o
 obj-$(CONFIG_VIDEO_NOON010PC30)	+= noon010pc30.o
 obj-$(CONFIG_VIDEO_S5K6AA)	+= s5k6aa.o
diff --git a/drivers/media/i2c/mt9m114.c b/drivers/media/i2c/mt9m114.c
new file mode 100755
index 0000000..55c7f10
--- /dev/null
+++ b/drivers/media/i2c/mt9m114.c
@@ -0,0 +1,2966 @@
+/*
+ * mt9m114.c Aptina MT9M114 sensor driver
+ *
+ * refer to: SoC Camera driver by Scott Jiang <Scott.Jiang.Linux@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+//#define DEBUG
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/i2c.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+#include <linux/videodev2.h>
+
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-mediabus.h>
+#include <media/media-entity.h>
+#include <dt-bindings/media/xilinx-vip.h>
+
+#include <linux/gpio/consumer.h>
+#include <linux/of_gpio.h>
+
+#define DRIVER_NAME		"mt9m114"
+
+#define dprintk(level, name,  fmt, arg...)\
+    do { \
+  printk(KERN_DEBUG "%s/0: " fmt, name, ## arg);\
+    } while (0)
+
+#define ARRAY_SIZE(a)  (sizeof(a)/sizeof((a)[0]))		
+
+/* Sysctl registers */
+#define MT9M114_CHIP_ID								0x0000
+#define MT9M114_COMMAND_REGISTER					0x0080
+#define MT9M114_COMMAND_REGISTER_APPLY_PATCH		(1 << 0)
+#define MT9M114_COMMAND_REGISTER_SET_STATE			(1 << 1)
+#define MT9M114_COMMAND_REGISTER_REFRESH			(1 << 2)
+#define MT9M114_COMMAND_REGISTER_WAIT_FOR_EVENT		(1 << 3)
+#define MT9M114_COMMAND_REGISTER_OK					(1 << 15)
+#define MT9M114_SOFT_RESET							0x001a
+#define MT9M114_PAD_SLEW							0x001e
+#define MT9M114_PAD_CONTROL							0x0032
+
+/* XDMA registers */
+#define MT9M114_ACCESS_CTL_STAT						0x0982
+#define MT9M114_PHYSICAL_ADDRESS_ACCESS				0x098a
+#define MT9M114_LOGICAL_ADDRESS_ACCESS				0x098e
+		
+/* Core registers */		
+#define MT9M114_RESET_REGISTER						0x301a
+#define MT9M114_FLASH								0x3046
+#define MT9M114_CUSTOMER_REV						0x31fe
+
+/* Camera Control registers */
+#define MT9M114_CAM_SENSOR_CFG_Y_ADDR_START			0xc800
+#define MT9M114_CAM_SENSOR_CFG_X_ADDR_START			0xc802
+#define MT9M114_CAM_SENSOR_CFG_Y_ADDR_END			0xc804
+#define MT9M114_CAM_SENSOR_CFG_X_ADDR_END			0xc806
+#define MT9M114_CAM_SENSOR_CFG_PIXCLK				0xc808
+#define MT9M114_CAM_SENSOR_CFG_ROW_SPEED			0xc80c
+#define MT9M114_CAM_SENSOR_CFG_FINE_INTEG_TIME_MIN	0xc80e
+#define MT9M114_CAM_SENSOR_CFG_FINE_INTEG_TIME_MAX	0xc810
+#define MT9M114_CAM_SENSOR_CFG_FRAME_LENGTH_LINES	0xc812
+#define MT9M114_CAM_SENSOR_CFG_LINE_LENGTH_PCK		0xc814
+#define MT9M114_CAM_SENSOR_CFG_FINE_CORRECTION		0xc816
+#define MT9M114_CAM_SENSOR_CFG_CPIPE_LAST_ROW		0xc818
+#define MT9M114_CAM_SENSOR_CFG_REG_0_DATA			0xc826
+#define MT9M114_CAM_SENSOR_CONTROL_READ_MODE		0xc834
+#define MT9M114_CAM_CROP_WINDOW_XOFFSET				0xc854
+#define MT9M114_CAM_CROP_WINDOW_YOFFSET				0xc856
+#define MT9M114_CAM_CROP_WINDOW_WIDTH				0xc858
+#define MT9M114_CAM_CROP_WINDOW_HEIGHT				0xc85a
+#define MT9M114_CAM_CROP_CROPMODE					0xc85c
+#define MT9M114_CAM_OUTPUT_WIDTH					0xc868
+#define MT9M114_CAM_OUTPUT_HEIGHT					0xc86a
+#define MT9M114_CAM_OUTPUT_FORMAT					0xc86c
+#define MT9M114_CAM_AET_AEMODE						0xc878
+#define MT9M114_CAM_AET_MAX_FRAME_RATE				0xc88c
+#define MT9M114_CAM_AET_MIN_FRAME_RATE				0xc88e
+#define MT9M114_CAM_AWB_AWB_XSCALE					0xc8f2
+#define MT9M114_CAM_AWB_AWB_YSCALE					0xc8f3
+#define MT9M114_CAM_AWB_AWB_XSHIFT_PRE_ADJ			0xc904
+#define MT9M114_CAM_AWB_AWB_YSHIFT_PRE_ADJ			0xc906
+#define MT9M114_CAM_STAT_AWB_CLIP_WINDOW_XSTART		0xc914
+#define MT9M114_CAM_STAT_AWB_CLIP_WINDOW_YSTART		0xc916
+#define MT9M114_CAM_STAT_AWB_CLIP_WINDOW_XEND		0xc918
+#define MT9M114_CAM_STAT_AWB_CLIP_WINDOW_YEND		0xc91a
+#define MT9M114_CAM_STAT_AE_INITIAL_WINDOW_XSTART	0xc91c
+#define MT9M114_CAM_STAT_AE_INITIAL_WINDOW_YSTART	0xc91e
+#define MT9M114_CAM_STAT_AE_INITIAL_WINDOW_XEND		0xc920
+#define MT9M114_CAM_STAT_AE_INITIAL_WINDOW_YEND		0xc922
+#define MT9M114_CAM_SYSCTL_PLL_ENABLE				0xc97e
+#define MT9M114_CAM_SYSCTL_PLL_DIVIDER_M_N			0xc980
+#define MT9M114_CAM_SYSCTL_PLL_DIVIDER_P			0xc982
+#define MT9M114_CAM_PORT_OUTPUT_CONTROL				0xc984
+
+/* System Manager registers */
+#define MT9M114_SYSMGR_NEXT_STATE					0xdc00
+#define MT9M114_SYSMGR_CURRENT_STATE				0xdc01
+#define MT9M114_SYSMGR_CMD_STATUS					0xdc02
+		
+/* Patch Loader registers */		
+#define MT9M114_PATCHLDR_LOADER_ADDRESS				0xe000
+#define MT9M114_PATCHLDR_PATCH_ID					0xe002
+#define MT9M114_PATCHLDR_FIRMWARE_ID				0xe004
+#define MT9M114_PATCHLDR_APPLY_STATUS				0xe008
+#define MT9M114_PATCHLDR_NUM_PATCHES				0xe009
+#define MT9M114_PATCHLDR_PATCH_ID_0					0xe00a
+#define MT9M114_PATCHLDR_PATCH_ID_1					0xe00c
+#define MT9M114_PATCHLDR_PATCH_ID_2					0xe00e
+#define MT9M114_PATCHLDR_PATCH_ID_3					0xe010
+#define MT9M114_PATCHLDR_PATCH_ID_4					0xe012
+#define MT9M114_PATCHLDR_PATCH_ID_5					0xe014
+#define MT9M114_PATCHLDR_PATCH_ID_6					0xe016
+#define MT9M114_PATCHLDR_PATCH_ID_7					0xe018
+
+/* SYS_STATE values (for SYSMGR_NEXT_STATE and SYSMGR_CURRENT_STATE) */
+#define MT9M114_SYS_STATE_ENTER_CONFIG_CHANGE		0x28
+#define MT9M114_SYS_STATE_STREAMING					0x31
+#define MT9M114_SYS_STATE_START_STREAMING			0x34
+#define MT9M114_SYS_STATE_ENTER_SUSPEND				0x40
+#define MT9M114_SYS_STATE_SUSPENDED					0x41
+#define MT9M114_SYS_STATE_ENTER_STANDBY				0x50
+#define MT9M114_SYS_STATE_STANDBY					0x52
+#define MT9M114_SYS_STATE_LEAVE_STANDBY				0x54
+	
+/* Result status of last SET_STATE comamnd */	
+#define MT9M114_SET_STATE_RESULT_ENOERR				0x00
+#define MT9M114_SET_STATE_RESULT_EINVAL				0x0c
+#define MT9M114_SET_STATE_RESULT_ENOSPC				0x0d
+
+#define MAX_FRAME_RATE 30
+
+//////////////// New code ////////////////
+/* Registers */
+
+#define REG_CHIP_ID                               0x0000
+#define REG_MON_MAJOR_VERSION                     0x8000
+#define REG_MON_MINOR_VERION                      0x8002
+#define REG_MON_RELEASE_VERSION                   0x8004
+#define REG_RESET_AND_MISC_CONTROL                0x001A
+#define REG_PAD_SLEW_CONTROL                      0x001E
+#define REG_COMMAND_REGISTER                      0x0080
+#define   HOST_COMMAND_APPLY_PATCH                0x0001
+#define   HOST_COMMAND_SET_STATE                  0x0002
+#define   HOST_COMMAND_REFRESH                    0x0004
+#define   HOST_COMMAND_WAIT_FOR_EVENT             0x0008
+#define   HOST_COMMAND_OK                         0x8000
+#define REG_ACCESS_CTL_STAT                       0x0982
+#define REG_PHYSICAL_ADDRESS_ACCESS               0x098A
+#define REG_LOGICAL_ADDRESS_ACCESS                0x098E
+#define MCU_VARIABLE_DATA0                        0x0990
+#define MCU_VARIABLE_DATA1                        0x0992
+#define REG_RESET_REGISTER                        0x301A  
+#define REG_DAC_TXLO_ROW                          0x316A 
+#define REG_DAC_TXLO                              0x316C 
+#define REG_DAC_LD_4_5                            0x3ED0
+#define REG_DAC_LD_6_7                            0x3ED2
+#define REG_DAC_ECL                               0x316E
+#define REG_DELTA_DK_CONTROL                      0x3180
+#define REG_SAMP_COL_PUP2                         0x3E14
+#define REG_COLUMN_CORRECTION                     0x30D4
+#define REG_LL_ALGO                               0xBC04
+#define LL_EXEC_DELTA_DK_CORRECTION               0x0200
+#define REG_CAM_DGAIN_RED                         0xC840
+#define REG_CAM_DGAIN_GREEN_1                     0xC842
+#define REG_CAM_DGAIN_GREEN_2                     0xC844
+#define REG_CAM_DGAIN_BLUE                        0xC846
+
+#define REG_CAM_SYSCTL_PLL_ENABLE                 0xC97E 
+#define REG_CAM_SYSCTL_PLL_DIVIDER_M_N            0xC980
+#define REG_CAM_SYSCTL_PLL_DIVIDER_P              0xC982
+#define REG_CAM_SENSOR_CFG_Y_ADDR_START           0xC800
+#define REG_CAM_SENSOR_CFG_X_ADDR_START           0xC802
+#define REG_CAM_SENSOR_CFG_Y_ADDR_END             0xC804
+#define REG_CAM_SENSOR_CFG_X_ADDR_END             0xC806
+#define REG_CAM_SENSOR_CFG_PIXCLK                 0xC808 
+#define REG_CAM_SENSOR_CFG_ROW_SPEED              0xC80C 
+#define REG_CAM_SENSOR_CFG_FINE_INTEG_TIME_MIN    0xC80E 
+#define REG_CAM_SENSOR_CFG_FINE_INTEG_TIME_MAX    0xC810 
+#define REG_CAM_SENSOR_CFG_FRAME_LENGTH_LINES     0xC812
+#define REG_CAM_SENSOR_CFG_LINE_LENGTH_PCK        0xC814
+#define REG_CAM_SENSOR_CFG_FINE_CORRECTION        0xC816
+#define REG_CAM_SENSOR_CFG_CPIPE_LAST_ROW         0xC818
+#define REG_CAM_SENSOR_CFG_REG_0_DATA             0xC826
+#define REG_CAM_SENSOR_CONTROL_READ_MODE          0xC834
+
+#define   CAM_SENSOR_CONTROL_VERT_FLIP_EN         0x0002
+#define   CAM_SENSOR_CONTROL_HORZ_FLIP_EN         0x0001
+#define   CAM_SENSOR_CONTROL_BINNING_EN           0x0330
+#define   CAM_SENSOR_CONTROL_SKIPPING_EN          0x0110
+#define   CAM_MON_HEARTBEAT                       0x8006 //the frame counter. updates on vertical blanking.
+
+#define REG_CAM_CROP_WINDOW_XOFFSET               0xC854
+#define REG_CAM_CROP_WINDOW_YOFFSET               0xC856
+#define REG_CAM_CROP_WINDOW_WIDTH                 0xC858
+#define REG_CAM_CROP_WINDOW_HEIGHT                0xC85A
+#define REG_CAM_CROP_CROPMODE                     0xC85C
+#define REG_CAM_OUTPUT_WIDTH                      0xC868
+#define REG_CAM_OUTPUT_HEIGHT                     0xC86A
+#define REG_CAM_OUTPUT_FORMAT                     0xC86C
+#define REG_CAM_OUTPUT_OFFSET                     0xC870
+#define REG_CAM_PORT_OUTPUT_CONTROL               0xC984
+#define REG_CAM_OUPUT_FORMAT_YUV                  0xC86E
+#define REG_CAM_STAT_AWB_CLIP_WINDOW_XSTART       0xC914
+#define REG_CAM_STAT_AWB_CLIP_WINDOW_YSTART       0xC916
+#define REG_CAM_STAT_AWB_CLIP_WINDOW_XEND         0xC918
+#define REG_CAM_STAT_AWB_CLIP_WINDOW_YEND         0xC91A
+#define REG_CAM_STAT_AE_INITIAL_WINDOW_XSTART     0xC91C
+#define REG_CAM_STAT_AE_INITIAL_WINDOW_YSTART     0xC91E
+#define REG_CAM_STAT_AE_INITIAL_WINDOW_XEND       0xC920
+#define REG_CAM_STAT_AE_INITIAL_WINDOW_YEND       0xC922
+#define REG_CAM_PGA_PGA_CONTROL                   0xC95E
+#define REG_SYSMGR_NEXT_STATE                     0xDC00
+#define REG_SYSMGR_CURRENT_STATE                  0xDC01
+#define REG_PATCHLDR_LOADER_ADDRESS               0xE000
+#define REG_PATCHLDR_PATCH_ID                     0xE002
+#define REG_PATCHLDR_FIRMWARE_ID                  0xE004
+#define REG_PATCHLDR_APPLY_STATUS                 0xE008
+#define REG_AUTO_BINNING_MODE                     0xE801
+#define REG_CAM_SENSOR_CFG_MAX_ANALOG_GAIN        0xC81C
+#define REG_CROP_CROPMODE                         0xC85C 
+#define REG_CAM_AET_AEMODE                        0xC878 
+#define REG_CAM_AET_TARGET_AVG_LUMA               0xC87A
+#define REG_CAM_AET_TARGET_AVERAGE_LUMA_DARK      0xC87B
+#define REG_CAM_AET_BLACK_CLIPPING_TARGET         0xC87C
+#define REG_CAM_AET_AE_MAX_VIRT_AGAIN             0xC886
+#define REG_CAM_AET_MAX_FRAME_RATE                0xC88C
+#define REG_CAM_AET_MIN_FRAME_RATE                0xC88E
+#define REG_CAM_AET_TARGET_GAIN                   0xC890
+#define REG_AE_ALGORITHM                          0xA404
+#define REG_AE_TRACK_MODE                         0xA802
+#define REG_AE_TRACK_AE_TRACKING_DAMPENING_SPEED  0xA80A
+
+#define REG_CAM_LL_START_BRIGHTNESS               0xC926
+#define REG_CAM_LL_STOP_BRIGHTNESS                0xC928
+#define REG_CAM_LL_START_GAIN_METRIC              0xC946
+#define REG_CAM_LL_STOP_GAIN_METRIC               0xC948
+#define REG_CAM_LL_START_TARGET_LUMA_BM           0xC952
+#define REG_CAM_LL_STOP_TARGET_LUMA_BM            0xC954
+#define REG_CAM_LL_START_SATURATION               0xC92A
+#define REG_CAM_LL_END_SATURATION                 0xC92B
+#define REG_CAM_LL_START_DESATURATION             0xC92C
+#define REG_CAM_LL_END_DESATURATION               0xC92D
+#define REG_CAM_LL_START_DEMOSAIC                 0xC92E
+#define REG_CAM_LL_START_AP_GAIN                  0xC92F
+#define REG_CAM_LL_START_AP_THRESH                0xC930
+#define REG_CAM_LL_STOP_DEMOSAIC                  0xC931
+#define REG_CAM_LL_STOP_AP_GAIN                   0xC932
+#define REG_CAM_LL_STOP_AP_THRESH                 0xC933
+#define REG_CAM_LL_START_NR_RED                   0xC934
+#define REG_CAM_LL_START_NR_GREEN                 0xC935
+#define REG_CAM_LL_START_NR_BLUE                  0xC936
+#define REG_CAM_LL_START_NR_THRESH                0xC937
+#define REG_CAM_LL_STOP_NR_RED                    0xC938
+#define REG_CAM_LL_STOP_NR_GREEN                  0xC939
+#define REG_CAM_LL_STOP_NR_BLUE                   0xC93A
+#define REG_CAM_LL_STOP_NR_THRESH                 0xC93B
+#define REG_CAM_LL_START_CONTRAST_BM              0xC93C
+#define REG_CAM_LL_STOP_CONTRAST_BM               0xC93E
+#define REG_CAM_LL_GAMMA                          0xC940
+#define REG_CAM_LL_START_CONTRAST_GRADIENT        0xC942
+#define REG_CAM_LL_STOP_CONTRAST_GRADIENT         0xC943
+#define REG_CAM_LL_START_CONTRAST_LUMA_PERCENTAGE 0xC944
+#define REG_CAM_LL_STOP_CONTRAST_LUMA_PERCENTAGE  0xC945
+#define REG_CAM_LL_START_FADE_TO_BLACK_LUMA       0xC94A
+#define REG_CAM_LL_STOP_FADE_TO_BLACK_LUMA        0xC94C
+#define REG_CAM_LL_CLUSTER_DC_TH_BM               0xC94E
+#define REG_CAM_LL_CLUSTER_DC_GATE_PERCENTAGE     0xC950
+#define REG_CAM_LL_SUMMING_SENSITIVITY_FACTOR     0xC951
+#define REG_CAM_LL_MODE                           0xBC02 //might be BC07.
+#define REG_CCM_DELTA_GAIN                        0xB42A
+
+
+
+#define REG_CAM_HUE_ANGLE                         0xC873
+
+// AWB
+#define REG_AWB_AWB_MODE                          0xC909
+#define REG_AWB_COL_TEMP                          0xC8F0//color temp, only writeable if awb mode is manual. in kelvin
+#define REG_AWB_COL_TEMP_MAX                      0xC8EE//maximum color temp in kelvin
+#define REG_AWB_COL_TEMP_MIN                      0xC8EC//minimum color temp in kelvin
+
+// UVC
+#define REG_UVC_AE_MODE                           0xCC00
+#define REG_UVC_AUTO_WHITE_BALANCE_TEMPERATURE    0xCC01
+#define REG_UVC_AE_PRIORITY                       0xCC02
+#define REG_UVC_POWER_LINE_FREQUENCY              0xCC03
+#define REG_UVC_EXPOSURE_TIME                     0xCC04
+#define REG_UVC_BACKLIGHT_COMPENSATION            0xCC08
+#define REG_UVC_BRIGHTNESS                        0xCC0A //set brightness in auto exposure mode.
+
+#define REG_UVC_CONTRAST                          0xCC0C //not exactly what the name suggests. See chip documentation 
+
+#define REG_UVC_GAIN                              0xCC0E
+#define REG_UVC_HUE                               0xCC10
+#define REG_UVC_SATURATION                        0xCC12
+#define REG_UVC_SHARPNESS                         0xCC14 
+#define REG_UVC_GAMMA                             0xCC16
+#define REG_UVC_WHITE_BALANCE_TEMPERATURE         0xCC18
+#define REG_UVC_FRAME_INTERVAL                    0xCC1C
+#define REG_UVC_MANUAL_EXPOSURE                   0xCC20
+#define REG_UVC_FLICKER_AVOIDANCE                 0xCC21
+#define REG_UVC_ALGO                              0xCC22
+#define REG_UVC_RESULT_STATUS                     0xCC24
+
+/**This variable selects the system event that the host wishes to wait for.
+ * 1: end of frame
+ * 2: start of frame */
+#define REG_CMD_HANDLER_WAIT_FOR_EVENT            0xFC00
+
+/** This variable determines the number of system event occurrences for which the
+ *  Command Handler component will wait */
+#define REG_CMD_HANDLER_NUM_WAIT_EVENTS           0xFC02
+
+/**Result status code for last refresh command. Updates after refresh command.
+ * Possible values:
+   0x00: ENOERR - refresh successful
+   0x13: EINVCROPX - invalid horizontal crop configuration
+   0x14: EINVCROPY - invalid vertical crop configuration
+   0x15: EINVTC - invalid Tilt Correction percentage
+*/
+
+#define REG_SEQ_ERROR_CODE                        0x8406
+
+
+/* SYS_STATE values (for SYSMGR_NEXT_STATE and SYSMGR_CURRENT_STATE) */
+#define MT9M114_SYS_STATE_ENTER_CONFIG_CHANGE           0x28
+#define MT9M114_SYS_STATE_STREAMING                     0x31
+#define MT9M114_SYS_STATE_START_STREAMING               0x34
+#define MT9M114_SYS_STATE_ENTER_SUSPEND                 0x40
+#define MT9M114_SYS_STATE_SUSPENDED                     0x41
+#define MT9M114_SYS_STATE_ENTER_STANDBY                 0x50
+#define MT9M114_SYS_STATE_STANDBY                       0x52
+#define MT9M114_SYS_STATE_LEAVE_STANDBY                 0x54
+
+//Custom V4L control variables
+#define V4L2_MT9M114_FADE_TO_BLACK (V4L2_CID_PRIVATE_BASE) //boolean, enable or disable fade to black feature
+
+static int check_uvc_status(struct v4l2_subdev *sd, const char* funcName);
+/////////////////////////////////////////
+
+
+enum {
+	SOURCE_PAD,
+	NUM_PADS
+};
+
+struct mt9m114_video_format {
+	unsigned int vf_code;
+	unsigned int width;
+	const char *pattern;
+	unsigned int mbus_code;
+	unsigned int bpp;
+	u32 fourcc;
+	const char *description;
+	enum v4l2_colorspace colorspace;
+};
+
+struct mt9m114_reg {
+	u16 reg;
+	u32 val;
+	int width;
+};
+
+enum {
+	MT9M114_QVGA,
+	MT9M114_VGA,
+	MT9M114_WVGA,
+	MT9M114_720P,
+};
+
+struct mt9m114_resolution {
+	unsigned int width;
+	unsigned int height;
+};
+
+#ifdef DEBUG
+static bool debug = 1;
+#else
+static bool debug = 0;
+#endif
+
+struct mt9m114_gpio {
+	int gpio;
+	int level;
+};
+
+/**
+ * This enum is used as index for the state's uvc_register_out_of_sync array.
+ */
+typedef enum {
+    UVC_EXPOSURE_TIME,
+    UVC_GAIN,
+    UVC_BRIGHTNESS,
+    UVC_CONTRAST,
+    UVC_SATURATION,
+    UVC_SHARPNESS,
+    NUM_OF_UVC_REGISTERS /** < This value should always be the last! */
+} uvc_registers;
+
+#define MAX_GPIO_NUM 	2
+struct mt9m114 {
+	struct device *dev;
+	struct i2c_client *client;
+	struct v4l2_subdev sd;
+	struct v4l2_ctrl_handler hdl;
+	struct v4l2_fract frame_rate;
+	struct media_pad pads[NUM_PADS];
+	unsigned int npads;
+	struct v4l2_mbus_framefmt formats[NUM_PADS];
+	struct v4l2_mbus_framefmt default_format;
+	const struct mt9m114_video_format *vid_format;
+	struct mt9m114_resolution cur_fs;
+	
+	struct mt9m114_gpio gpio[MAX_GPIO_NUM];
+	int gpio_state[MAX_GPIO_NUM];
+	
+	/* The change config command sometimes breaks the sync between uvc registers and cam
+	 * variables. This array keeps track of which uvc registers are out of sync 
+	 * and which are not. Use the uvc_registers enum to access this array 
+	 */
+	bool uvc_register_out_of_sync[NUM_OF_UVC_REGISTERS]; 
+};
+
+static const struct mt9m114_video_format mt9m114_supported_video_formats[] = {
+	{ XVIP_VF_MONO_SENSOR, 	8, "rggb", 	MEDIA_BUS_FMT_SRGGB8_1X8, 	1, V4L2_PIX_FMT_SRGGB8, "Bayer 8-bit RGGB", 	V4L2_COLORSPACE_SRGB },
+	{ XVIP_VF_MONO_SENSOR, 	8, "grbg", 	MEDIA_BUS_FMT_SGRBG8_1X8, 	1, V4L2_PIX_FMT_SGRBG8, "Bayer 8-bit GRBG", 	V4L2_COLORSPACE_SRGB },
+	{ XVIP_VF_MONO_SENSOR, 	8, "gbrg", 	MEDIA_BUS_FMT_SGBRG8_1X8, 	1, V4L2_PIX_FMT_SGBRG8, "Bayer 8-bit GBRG", 	V4L2_COLORSPACE_SRGB },
+	{ XVIP_VF_MONO_SENSOR, 	8, "bggr", 	MEDIA_BUS_FMT_SBGGR8_1X8, 	1, V4L2_PIX_FMT_SBGGR8, "Bayer 8-bit BGGR", 	V4L2_COLORSPACE_SRGB },
+};
+
+static const struct mt9m114_resolution mt9m114_resolutions[] = {
+	[MT9M114_QVGA] = {
+		.width  = 320,
+		.height = 240,
+	},
+	[MT9M114_VGA] = {
+		.width  = 640,
+		.height = 480,
+	},
+	[MT9M114_WVGA] = {
+		.width  = 800,
+		.height = 480,
+	},
+	[MT9M114_720P] = {
+		.width  = 1280,
+		.height = 720,
+	},
+};
+
+static const struct mt9m114_reg mt9m114_init[] = {
+#if 0
+	{ MT9M114_RESET_REGISTER,                        0x0218, 2 },
+
+	/* PLL settings */
+	{ MT9M114_LOGICAL_ADDRESS_ACCESS,                0x0000, 2 },
+	{ MT9M114_CAM_SYSCTL_PLL_ENABLE,                 0x01,   1 },
+	{ MT9M114_CAM_SYSCTL_PLL_DIVIDER_M_N,            0x0120, 2 },
+	{ MT9M114_CAM_SYSCTL_PLL_DIVIDER_P,              0x0700, 2 },
+#endif
+	//{ MT9M114_CAM_SENSOR_CFG_PIXCLK,                 0x2DC6C00, 4 },
+	
+#if 0
+	/* Sensor optimization */
+	{ 0x316A, 0x8270, 2 },
+	{ 0x316C, 0x8270, 2 },
+	{ 0x3ED0, 0x2305, 2 },
+	{ 0x3ED2, 0x77CF, 2 },
+	{ 0x316E, 0x8202, 2 },
+	{ 0x3180, 0x87FF, 2 },
+	{ 0x30D4, 0x6080, 2 },
+	{ 0xA802, 0x0008, 2 },
+	{ 0x3E14, 0xFF39, 2 },
+
+	/* APGA */
+	{ 0xC95E, 0x0000, 2 },
+
+	/* Camera control module   */
+	{ 0xC892, 0x0267, 2 },
+	{ 0xC894, 0xFF1A, 2 },
+	{ 0xC896, 0xFFB3, 2 },
+	{ 0xC898, 0xFF80, 2 },
+	{ 0xC89A, 0x0166, 2 },
+	{ 0xC89C, 0x0003, 2 },
+	{ 0xC89E, 0xFF9A, 2 },
+	{ 0xC8A0, 0xFEB4, 2 },
+	{ 0xC8A2, 0x024D, 2 },
+	{ 0xC8A4, 0x01BF, 2 },
+	{ 0xC8A6, 0xFF01, 2 },
+	{ 0xC8A8, 0xFFF3, 2 },
+	{ 0xC8AA, 0xFF75, 2 },
+	{ 0xC8AC, 0x0198, 2 },
+	{ 0xC8AE, 0xFFFD, 2 },
+	{ 0xC8B0, 0xFF9A, 2 },
+	{ 0xC8B2, 0xFEE7, 2 },
+	{ 0xC8B4, 0x02A8, 2 },
+	{ 0xC8B6, 0x01D9, 2 },
+	{ 0xC8B8, 0xFF26, 2 },
+	{ 0xC8BA, 0xFFF3, 2 },
+	{ 0xC8BC, 0xFFB3, 2 },
+	{ 0xC8BE, 0x0132, 2 },
+	{ 0xC8C0, 0xFFE8, 2 },
+	{ 0xC8C2, 0xFFDA, 2 },
+	{ 0xC8C4, 0xFECD, 2 },
+	{ 0xC8C6, 0x02C2, 2 },
+	{ 0xC8C8, 0x0075, 2 },
+	{ 0xC8CA, 0x011C, 2 },
+	{ 0xC8CC, 0x009A, 2 },
+	{ 0xC8CE, 0x0105, 2 },
+	{ 0xC8D0, 0x00A4, 2 },
+	{ 0xC8D2, 0x00AC, 2 },
+	{ 0xC8D4, 0x0A8C, 2 },
+	{ 0xC8D6, 0x0F0A, 2 },
+	{ 0xC8D8, 0x1964, 2 },
+
+	/* Automatic White balance */
+	{ MT9M114_CAM_AWB_AWB_XSHIFT_PRE_ADJ,            0x0033, 2 },
+	{ MT9M114_CAM_AWB_AWB_YSHIFT_PRE_ADJ,            0x003C, 2 },
+	{ MT9M114_CAM_AWB_AWB_XSCALE,                    0x03,   1 },
+	{ MT9M114_CAM_AWB_AWB_YSCALE,                    0x02,   1 },
+	{ 0xC8F4, 0x0000, 2 },
+	{ 0xC8F6, 0x0000, 2 },
+	{ 0xC8F8, 0x0000, 2 },
+	{ 0xC8FA, 0xE724, 2 },
+	{ 0xC8FC, 0x1583, 2 },
+	{ 0xC8FE, 0x2045, 2 },
+	{ 0xC900, 0x03FF, 2 },
+	{ 0xC902, 0x007C, 2 },
+	{ 0xC90C, 0x80,   1 },
+	{ 0xC90D, 0x80,   1 },
+	{ 0xC90E, 0x80,   1 },
+	{ 0xC90F, 0x88,   1 },
+	{ 0xC910, 0x80,   1 },
+	{ 0xC911, 0x80,   1 },
+
+	/* CPIPE Preference */
+	{ 0xC926, 0x0020, 2 }, 
+	{ 0xC928, 0x009A, 2 }, 
+	{ 0xC946, 0x0070, 2 },
+	{ 0xC948, 0x00F3, 2 },
+	{ 0xC944, 0x20,   1 },
+	{ 0xC945, 0x9A,   1 },
+	{ 0xC92A, 0x80,   1 },
+	{ 0xC92B, 0x4B,   1 },
+	{ 0xC92C, 0x00,   1 },
+	{ 0xC92D, 0xFF,   1 },
+	{ 0xC92E, 0x3C,   1 },
+	{ 0xC92F, 0x02,   1 },
+	{ 0xC930, 0x06,   1 },
+	{ 0xC931, 0x64,   1 },
+	{ 0xC932, 0x01,   1 },
+	{ 0xC933, 0x0C,   1 },
+	{ 0xC934, 0x3C,   1 },
+	{ 0xC935, 0x3C,   1 },
+	{ 0xC936, 0x3C,   1 },
+	{ 0xC937, 0x0F,   1 },
+	{ 0xC938, 0x64,   1 },
+	{ 0xC939, 0x64,   1 },
+	{ 0xC93A, 0x64,   1 },
+	{ 0xC93B, 0x32,   1 },
+	{ 0xC93C, 0x0020, 2 },
+	{ 0xC93E, 0x009A, 2 },
+	{ 0xC940, 0x00DC, 2 },
+	{ 0xC942, 0x38,   1 },
+	{ 0xC943, 0x30,   1 },
+	{ 0xC944, 0x50,   1 },
+	{ 0xC945, 0x19,   1 },
+	{ 0xC94A, 0x0230, 2 },
+	{ 0xC94C, 0x0010, 2 },
+	{ 0xC94E, 0x01CD, 2 },
+	{ 0xC950, 0x05,   1 },
+	{ 0xC951, 0x40,   1 },
+	{ 0xC87B, 0x1B,   1 },
+	{ MT9M114_CAM_AET_AEMODE, 0x0E, 1 },
+	{ 0xC890, 0x0080, 2 },
+	{ 0xC886, 0x0100, 2 },
+	{ 0xC87C, 0x005A, 2 },
+	{ 0xB42A, 0x05,   1 },
+	{ 0xA80A, 0x20,   1 },
+#endif
+	{ MT9M114_LOGICAL_ADDRESS_ACCESS,                0x0000, 2 },
+	{ MT9M114_CAM_PORT_OUTPUT_CONTROL,               0x8040/*0x8050*/, 2 }, // raw10
+	//{ MT9M114_CAM_PORT_OUTPUT_CONTROL,               0x8044, 2 }, // no truncate, slow down
+	//{ MT9M114_CAM_PORT_OUTPUT_CONTROL,               0x8060, 2 }, // pixclk only in valid
+	{ MT9M114_PAD_SLEW,                              0x0577, 2 },
+	{ 0xA404,                        0x03,   2 	}, // 0xA404, Adaptive for Lowlights
+	{ 0xC878,                        0x01,   1 	}, // 0xC878, Adaptive AE target
+};
+
+static const struct mt9m114_reg mt9m114_regs_qvga[] = { // 320x240
+	{ MT9M114_LOGICAL_ADDRESS_ACCESS,                0x1000, 2 },
+	{ MT9M114_CAM_SENSOR_CFG_Y_ADDR_START,           0x0000, 2 },
+	{ MT9M114_CAM_SENSOR_CFG_X_ADDR_START,           0x0000, 2 },
+	{ MT9M114_CAM_SENSOR_CFG_Y_ADDR_END,             0x03CD, 2 },
+	{ MT9M114_CAM_SENSOR_CFG_X_ADDR_END,             0x050D, 2 },
+	{ MT9M114_CAM_SENSOR_CFG_ROW_SPEED,              0x0001, 2 },
+	{ MT9M114_CAM_SENSOR_CFG_FINE_INTEG_TIME_MIN,    0x01C3, 2 },
+	{ MT9M114_CAM_SENSOR_CFG_FINE_INTEG_TIME_MAX,    0x03F7, 2 },
+	{ MT9M114_CAM_SENSOR_CFG_FRAME_LENGTH_LINES,     0x0500, 2 },
+	{ MT9M114_CAM_SENSOR_CFG_LINE_LENGTH_PCK,        0x04E2, 2 },
+	{ MT9M114_CAM_SENSOR_CFG_FINE_CORRECTION,        0x00E0, 2 },
+	{ MT9M114_CAM_SENSOR_CFG_CPIPE_LAST_ROW,         0x01E3, 2 },
+	{ MT9M114_CAM_SENSOR_CFG_REG_0_DATA,             0x0020, 2 },
+	{ MT9M114_CAM_CROP_WINDOW_XOFFSET,               0x0000, 2 },
+	{ MT9M114_CAM_CROP_WINDOW_YOFFSET,               0x0000, 2 },
+	{ MT9M114_CAM_CROP_WINDOW_WIDTH,                 0x0280, 2 }, // 640
+	{ MT9M114_CAM_CROP_WINDOW_HEIGHT,                0x01E0, 2 }, // 480
+	{ MT9M114_CAM_CROP_CROPMODE,                     0x03,   1 },
+	{ MT9M114_CAM_OUTPUT_WIDTH,                      0x0140, 2 }, // 320
+	{ MT9M114_CAM_OUTPUT_HEIGHT,                     0x00F0, 2 }, // 240
+	{ MT9M114_CAM_AET_AEMODE,                        0x00,   1 },
+	{ MT9M114_CAM_STAT_AWB_CLIP_WINDOW_XSTART,       0x0000, 2 },
+	{ MT9M114_CAM_STAT_AWB_CLIP_WINDOW_YSTART,       0x0000, 2 },
+	{ MT9M114_CAM_STAT_AWB_CLIP_WINDOW_XEND,         0x013F, 2 },
+	{ MT9M114_CAM_STAT_AWB_CLIP_WINDOW_YEND,         0x00EF, 2 },
+	{ MT9M114_CAM_STAT_AE_INITIAL_WINDOW_XSTART,     0x0000, 2 },
+	{ MT9M114_CAM_STAT_AE_INITIAL_WINDOW_YSTART,     0x0000, 2 },
+	{ MT9M114_CAM_STAT_AE_INITIAL_WINDOW_XEND,       0x003F, 2 },
+	{ MT9M114_CAM_STAT_AE_INITIAL_WINDOW_YEND,       0x002F, 2 },
+};
+
+static const struct mt9m114_reg mt9m114_regs_vga[] = { // 640x480
+	{ MT9M114_LOGICAL_ADDRESS_ACCESS,                0x1000, 2 },
+	{ MT9M114_CAM_SENSOR_CFG_Y_ADDR_START,           0x0000, 2 },
+	{ MT9M114_CAM_SENSOR_CFG_X_ADDR_START,           0x0000, 2 },
+	{ MT9M114_CAM_SENSOR_CFG_Y_ADDR_END,             0x03CD, 2 },
+	{ MT9M114_CAM_SENSOR_CFG_X_ADDR_END,             0x050D, 2 },
+	{ MT9M114_CAM_SENSOR_CFG_ROW_SPEED,              0x0001, 2 },
+	{ MT9M114_CAM_SENSOR_CFG_FINE_INTEG_TIME_MIN,    0x01C3, 2 },
+	{ MT9M114_CAM_SENSOR_CFG_FINE_INTEG_TIME_MAX,    0x03F7, 2 },
+	{ MT9M114_CAM_SENSOR_CFG_FRAME_LENGTH_LINES,     0x0500, 2 },
+	{ MT9M114_CAM_SENSOR_CFG_LINE_LENGTH_PCK,        0x04E2, 2 },
+	{ MT9M114_CAM_SENSOR_CFG_FINE_CORRECTION,        0x00E0, 2 },
+	{ MT9M114_CAM_SENSOR_CFG_CPIPE_LAST_ROW,         0x01E3, 2 },
+	{ MT9M114_CAM_SENSOR_CFG_REG_0_DATA,             0x0020, 2 },
+	{ MT9M114_CAM_CROP_WINDOW_XOFFSET,               0x0000, 2 },
+	{ MT9M114_CAM_CROP_WINDOW_YOFFSET,               0x0000, 2 },
+	{ MT9M114_CAM_CROP_WINDOW_WIDTH,                 0x0280, 2 }, // 640 
+	{ MT9M114_CAM_CROP_WINDOW_HEIGHT,                0x01E0, 2 }, // 480
+	{ MT9M114_CAM_CROP_CROPMODE,                     0x03,   1 }, 
+	{ MT9M114_CAM_OUTPUT_WIDTH,                      0x0280, 2 }, // 640
+	{ MT9M114_CAM_OUTPUT_HEIGHT,                     0x01E0, 2 }, // 480
+	{ MT9M114_CAM_AET_AEMODE,                        0x00,   1 },
+	{ MT9M114_CAM_STAT_AWB_CLIP_WINDOW_XSTART,       0x0000, 2 },
+	{ MT9M114_CAM_STAT_AWB_CLIP_WINDOW_YSTART,       0x0000, 2 },
+	{ MT9M114_CAM_STAT_AWB_CLIP_WINDOW_XEND,         0x027F, 2 },
+	{ MT9M114_CAM_STAT_AWB_CLIP_WINDOW_YEND,         0x01DF, 2 },
+	{ MT9M114_CAM_STAT_AE_INITIAL_WINDOW_XSTART,     0x0000, 2 },
+	{ MT9M114_CAM_STAT_AE_INITIAL_WINDOW_YSTART,     0x0000, 2 },
+	{ MT9M114_CAM_STAT_AE_INITIAL_WINDOW_XEND,       0x007F, 2 },
+	{ MT9M114_CAM_STAT_AE_INITIAL_WINDOW_YEND,       0x005F, 2 },
+};
+
+static const struct mt9m114_reg mt9m114_regs_wvga[] = { // 800x480
+	{ MT9M114_LOGICAL_ADDRESS_ACCESS,                0x1000, 2 },
+	{ MT9M114_CAM_SENSOR_CFG_Y_ADDR_START,           0x00F4, 2 },
+	{ MT9M114_CAM_SENSOR_CFG_X_ADDR_START,           0x00F4, 2 },
+	{ MT9M114_CAM_SENSOR_CFG_Y_ADDR_END,             0x02DB, 2 },
+	{ MT9M114_CAM_SENSOR_CFG_X_ADDR_END,             0x041B, 2 },
+	{ MT9M114_CAM_SENSOR_CFG_ROW_SPEED,              0x0001, 2 },
+	{ MT9M114_CAM_SENSOR_CFG_FINE_INTEG_TIME_MIN,    0x00DB, 2 },
+	{ MT9M114_CAM_SENSOR_CFG_FINE_INTEG_TIME_MAX,    0x045F, 2 },
+	{ MT9M114_CAM_SENSOR_CFG_FRAME_LENGTH_LINES,     0x0500, 2 },
+	{ MT9M114_CAM_SENSOR_CFG_LINE_LENGTH_PCK,        0x04E2, 2 },
+	{ MT9M114_CAM_SENSOR_CFG_FINE_CORRECTION,        0x0060, 2 },
+	{ MT9M114_CAM_SENSOR_CFG_CPIPE_LAST_ROW,         0x01E3, 2 },
+	{ MT9M114_CAM_SENSOR_CFG_REG_0_DATA,             0x0020, 2 },
+	{ MT9M114_CAM_CROP_WINDOW_XOFFSET,               0x0000, 2 },
+	{ MT9M114_CAM_CROP_WINDOW_YOFFSET,               0x0000, 2 },
+	{ MT9M114_CAM_CROP_WINDOW_WIDTH,                 0x0320, 2 }, // 800
+	{ MT9M114_CAM_CROP_WINDOW_HEIGHT,                0x01E0, 2 }, // 480
+	{ MT9M114_CAM_CROP_CROPMODE,                     0x03,   1 },
+	{ MT9M114_CAM_OUTPUT_WIDTH,                      0x0320, 2 }, // 800
+	{ MT9M114_CAM_OUTPUT_HEIGHT,                     0x01E0, 2 }, // 480
+	{ MT9M114_CAM_AET_AEMODE,                        0x00,   1 },
+	{ MT9M114_CAM_STAT_AWB_CLIP_WINDOW_XSTART,       0x0000, 2 },
+	{ MT9M114_CAM_STAT_AWB_CLIP_WINDOW_YSTART,       0x0000, 2 },
+	{ MT9M114_CAM_STAT_AWB_CLIP_WINDOW_XEND,         0x031F, 2 },
+	{ MT9M114_CAM_STAT_AWB_CLIP_WINDOW_YEND,         0x01DF, 2 },
+	{ MT9M114_CAM_STAT_AE_INITIAL_WINDOW_XSTART,     0x0000, 2 },
+	{ MT9M114_CAM_STAT_AE_INITIAL_WINDOW_YSTART,     0x0000, 2 },
+	{ MT9M114_CAM_STAT_AE_INITIAL_WINDOW_XEND,       0x009F, 2 },
+	{ MT9M114_CAM_STAT_AE_INITIAL_WINDOW_YEND,       0x005F, 2 },
+};
+
+#if 0
+static const struct mt9m114_reg mt9m114_regs_720p[] = { // 1280x720
+	{ MT9M114_LOGICAL_ADDRESS_ACCESS,                0x1000, 2 	},
+	{ MT9M114_CAM_SENSOR_CFG_Y_ADDR_START,           124, 2 	}, // 0xC800 	(1st row of visible data), 0x007C
+	{ MT9M114_CAM_SENSOR_CFG_X_ADDR_START,           4, 2 		}, // 0xC802
+	{ MT9M114_CAM_SENSOR_CFG_Y_ADDR_END,             851, 2 	}, // 0xC804 	(last row of visible data), 0x0335
+	{ MT9M114_CAM_SENSOR_CFG_X_ADDR_END,             1291, 2 	}, // 0xC806, 	0x50B
+	{ MT9M114_CAM_SENSOR_CFG_ROW_SPEED,              0x0001, 2 	},
+	{ MT9M114_CAM_SENSOR_CFG_FINE_INTEG_TIME_MIN,    219, 2 	}, // 			0x00DB
+	{ MT9M114_CAM_SENSOR_CFG_FINE_INTEG_TIME_MAX,    1558, 2 	}, // 			0x0616
+	{ MT9M114_CAM_SENSOR_CFG_FRAME_LENGTH_LINES,     778, 2 	}, // 0xC812 	(visible + vbank lines), 0x030A
+	{ MT9M114_CAM_SENSOR_CFG_LINE_LENGTH_PCK,        1689, 2	}, // 			0x0699
+	{ MT9M114_CAM_SENSOR_CFG_FINE_CORRECTION,        96, 2 		}, // 			0x0060
+	{ MT9M114_CAM_SENSOR_CFG_CPIPE_LAST_ROW,         723, 2 	}, // 0xC818,	0x02D3
+	{ MT9M114_CAM_SENSOR_CFG_REG_0_DATA,             0x0020, 2 	},
+	{ MT9M114_CAM_CROP_WINDOW_XOFFSET,               0x0000, 2 	}, // 0xC854
+	{ MT9M114_CAM_CROP_WINDOW_YOFFSET,               0x0000, 2 	}, // 0xC856
+	{ MT9M114_CAM_CROP_WINDOW_WIDTH,                 1280, 2 	}, // 0xC858,	0x0500
+	{ MT9M114_CAM_CROP_WINDOW_HEIGHT,                720, 2 	}, // 0xC85A,	0x02D0
+	{ MT9M114_CAM_CROP_CROPMODE,                     0x03,   1 	},
+	{ MT9M114_CAM_OUTPUT_WIDTH,                      1280, 2 	}, // 0xC868,	0x0500
+	{ MT9M114_CAM_OUTPUT_HEIGHT,                     720, 2 	}, // 0xC86A,	0x02D0
+	{ MT9M114_CAM_AET_AEMODE,                        0x00,   1 	}, // 0xC878,	 
+	{ MT9M114_CAM_STAT_AWB_CLIP_WINDOW_XSTART,       0x0000, 2 	},
+	{ MT9M114_CAM_STAT_AWB_CLIP_WINDOW_YSTART,       0x0000, 2 	},
+	{ MT9M114_CAM_STAT_AWB_CLIP_WINDOW_XEND,         1279, 2 	}, //			0x04FF
+	{ MT9M114_CAM_STAT_AWB_CLIP_WINDOW_YEND,         719, 2 	}, //			0x02CF
+	{ MT9M114_CAM_STAT_AE_INITIAL_WINDOW_XSTART,     0x0000, 2 	},
+	{ MT9M114_CAM_STAT_AE_INITIAL_WINDOW_YSTART,     0x0000, 2 	},
+	{ MT9M114_CAM_STAT_AE_INITIAL_WINDOW_XEND,       255, 2 	},
+	{ MT9M114_CAM_STAT_AE_INITIAL_WINDOW_YEND,       143, 2 	},
+};
+#endif
+static const struct mt9m114_reg mt9m114_regs_720p[] = { // 1280x720
+	{ MT9M114_LOGICAL_ADDRESS_ACCESS,                0x1000, 2 	},
+	{ MT9M114_CAM_SENSOR_CFG_Y_ADDR_START,           124, 2 	}, // 0xC800 	(1st row of visible data), 0x007C
+	{ MT9M114_CAM_SENSOR_CFG_X_ADDR_START,           4, 2 		}, // 0xC802
+	{ MT9M114_CAM_SENSOR_CFG_Y_ADDR_END,             851, 2 	}, // 0xC804 	(last row of visible data), 0x0335
+	{ MT9M114_CAM_SENSOR_CFG_X_ADDR_END,             1291, 2 	}, // 0xC806, 	0x50B
+	{ MT9M114_CAM_SENSOR_CFG_ROW_SPEED,              0x0001, 2 	},
+	{ MT9M114_CAM_SENSOR_CFG_FINE_INTEG_TIME_MIN,    219, 2 	}, // 			0x00DB
+	{ MT9M114_CAM_SENSOR_CFG_FINE_INTEG_TIME_MAX,    1558, 2 	}, // 			0x0616
+	{ MT9M114_CAM_SENSOR_CFG_FRAME_LENGTH_LINES,     778, 2 	}, // 0xC812 	(visible + vbank lines), 0x030A
+	{ MT9M114_CAM_SENSOR_CFG_LINE_LENGTH_PCK,        1689, 2	}, // 			0x0699
+	{ MT9M114_CAM_SENSOR_CFG_FINE_CORRECTION,        96, 2 		}, // 			0x0060
+	{ MT9M114_CAM_SENSOR_CFG_CPIPE_LAST_ROW,         723, 2 	}, // 0xC818,	0x02D3
+	{ MT9M114_CAM_SENSOR_CFG_REG_0_DATA,             0x0020, 2 	},
+	{ MT9M114_CAM_CROP_WINDOW_XOFFSET,               0x0000, 2 	}, // 0xC854
+	{ MT9M114_CAM_CROP_WINDOW_YOFFSET,               0x0000, 2 	}, // 0xC856
+	{ MT9M114_CAM_CROP_WINDOW_WIDTH,                 1280, 2 	}, // 0xC858,	0x0500
+	{ MT9M114_CAM_CROP_WINDOW_HEIGHT,                720, 2 	}, // 0xC85A,	0x02D0
+	{ MT9M114_CAM_CROP_CROPMODE,                     0x03,   1 	},
+	{ MT9M114_CAM_OUTPUT_WIDTH,                      1280, 2 	}, // 0xC868,	0x0500
+	{ MT9M114_CAM_OUTPUT_HEIGHT,                     720, 2 	}, // 0xC86A,	0x02D0
+	/// testing 
+	//{ 0xA404,                        0x03,   2 	}, // 0xA404, Adaptive for Lowlights
+	//{ 0xC878,                        0x01,   1 	}, // 0xC878, Adaptive AE target
+#if 0
+	{ 0xC87A,                        0x37,   1 	}, // 0xC87A, Luma value target for AE Track (0x37)
+	{ 0xC87B,                        0x60,   1 	}, // 0xC87B, Target average brightness for dark conditions when Adaptive Target Luma is enabled (0x60)
+	{ 0xC909,                        0x03,   1 	}, // AWB control, enable AWB & AE
+	//{ 0xC8F0,                        0x1900, 2 	}, // Color temp, color temp > temp threshold -> blue tint
+#endif
+	{ MT9M114_CAM_STAT_AWB_CLIP_WINDOW_XSTART,       0x0000, 2 	},
+	{ MT9M114_CAM_STAT_AWB_CLIP_WINDOW_YSTART,       0x0000, 2 	},
+	{ MT9M114_CAM_STAT_AWB_CLIP_WINDOW_XEND,         1279, 2 	}, //			0x04FF
+	{ MT9M114_CAM_STAT_AWB_CLIP_WINDOW_YEND,         719, 2 	}, //			0x02CF
+	{ MT9M114_CAM_STAT_AE_INITIAL_WINDOW_XSTART,     0x0000, 2 	},
+	{ MT9M114_CAM_STAT_AE_INITIAL_WINDOW_YSTART,     0x0000, 2 	},
+	{ MT9M114_CAM_STAT_AE_INITIAL_WINDOW_XEND,       255, 2 	},
+	{ MT9M114_CAM_STAT_AE_INITIAL_WINDOW_YEND,       143, 2 	},
+};
+
+static inline struct mt9m114 *to_mt9m114(struct v4l2_subdev *sd)
+{
+	return container_of(sd, struct mt9m114, sd);
+}
+static inline struct v4l2_subdev *to_sd(struct v4l2_ctrl *ctrl)
+{
+	return &container_of(ctrl->handler, struct mt9m114, hdl)->sd;
+}
+
+static int mt9m114_write8(struct i2c_client *client, u16 reg, u8 val)
+{
+	int ret;
+	struct {
+		u16 reg;
+		u8 val;
+	} __packed buf;
+	struct i2c_msg msg = {
+		.addr   = client->addr,
+		.flags  = 0,
+		.len    = 3,
+		.buf    = (u8 *)&buf,
+	};
+	buf.reg = swab16(reg);
+	buf.val = val;
+
+	ret = i2c_transfer(client->adapter, &msg, 1);
+	if (ret < 0) {
+		v4l_err(client, "Failed to write register 0x%04x!\n", reg);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int mt9m114_read16(struct i2c_client *client, u16 reg, u16 *val)
+{
+	int ret;
+	u16 rval;
+	struct i2c_msg msg[] = {
+		{
+			.addr   = client->addr,
+			.flags  = 0,
+			.len    = 2,
+			.buf    = (u8 *)&reg,
+		},
+		{
+			.addr   = client->addr,
+			.flags  = I2C_M_RD,
+			.len    = 2,
+			.buf    = (u8 *)&rval,
+		},
+	};
+
+	reg = swab16(reg);
+
+	ret = i2c_transfer(client->adapter, msg, 2);
+	if (ret < 0) {
+		v4l_err(client, "Failed to read register 0x%04x!\n", reg);
+		return ret;
+	}
+	*val = swab16(rval);
+
+	return 0;
+}
+
+static int mt9m114_write16(struct i2c_client *client, u16 reg, u16 val)
+{
+	int ret;
+	struct {
+		u16 reg;
+		u16 val;
+	} __packed buf;
+	struct i2c_msg msg = {
+		.addr   = client->addr,
+		.flags  = 0,
+		.len    = 4,
+		.buf    = (u8 *)&buf,
+	};
+	buf.reg = swab16(reg);
+	buf.val = swab16(val);
+
+	ret = i2c_transfer(client->adapter, &msg, 1);
+	if (ret < 0) {
+		v4l_err(client, "Failed to write register 0x%04x!\n", reg);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int mt9m114_write32(struct i2c_client *client, u16 reg, u32 val)
+{
+	int ret;
+	struct {
+		u16 reg;
+		u32 val;
+	} __packed buf;
+	struct i2c_msg msg = {
+		.addr   = client->addr,
+		.flags  = 0,
+		.len    = 6,
+		.buf    = (u8 *)&buf,
+	};
+	buf.reg = swab16(reg);
+	buf.val = swab32(val);
+
+	ret = i2c_transfer(client->adapter, &msg, 1);
+	if (ret < 0) {
+		v4l_err(client, "Failed to write register 0x%04x!\n", reg);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int mt9m114_writeregs(struct i2c_client *client,
+		const struct mt9m114_reg *regs, int len)
+{
+	int i, ret;
+
+	for (i = 0; i < len; i++) {
+		switch (regs[i].width) {
+		case 1:
+			ret = mt9m114_write8(client,
+					regs[i].reg, regs[i].val);
+			break;
+		case 2:
+			ret = mt9m114_write16(client,
+					regs[i].reg, regs[i].val);
+			break;
+		case 4:
+			ret = mt9m114_write32(client,
+					regs[i].reg, regs[i].val);
+			break;
+		default:
+			ret = -EINVAL;
+			break;
+		}
+		if (ret < 0)
+			return ret;
+	}
+	return 0;
+}
+
+static void mt9m114_res_roundup(u32 *width, u32 *height)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(mt9m114_resolutions); i++)
+		if ((mt9m114_resolutions[i].width >= *width) &&
+				(mt9m114_resolutions[i].height >= *height)) {
+			*width = mt9m114_resolutions[i].width;
+			*height = mt9m114_resolutions[i].height;
+			return;
+		}
+	*width = mt9m114_resolutions[MT9M114_720P].width;
+	*height = mt9m114_resolutions[MT9M114_720P].height;
+}
+
+static int mt9m114_set_res(struct i2c_client *client, u32 width, u32 height)
+{
+	u16 read_mode;
+	if ((width == mt9m114_resolutions[MT9M114_QVGA].width)
+		&& (height == mt9m114_resolutions[MT9M114_QVGA].height)) {
+		mt9m114_writeregs(client, mt9m114_regs_qvga,
+				ARRAY_SIZE(mt9m114_regs_qvga));
+		mt9m114_read16(client,
+			MT9M114_CAM_SENSOR_CONTROL_READ_MODE, &read_mode);
+		read_mode = (read_mode & 0xfccf) | 0x0330;
+		mt9m114_write16(client,
+			MT9M114_CAM_SENSOR_CONTROL_READ_MODE, read_mode);
+	} else if ((width == mt9m114_resolutions[MT9M114_VGA].width)
+		&& (height == mt9m114_resolutions[MT9M114_VGA].height)) {
+		mt9m114_writeregs(client, mt9m114_regs_vga,
+				ARRAY_SIZE(mt9m114_regs_vga));
+		mt9m114_read16(client,
+			MT9M114_CAM_SENSOR_CONTROL_READ_MODE, &read_mode);
+		read_mode = (read_mode & 0xfccf) | 0x0330;
+		mt9m114_write16(client,
+			MT9M114_CAM_SENSOR_CONTROL_READ_MODE, read_mode);
+	} else if ((width == mt9m114_resolutions[MT9M114_WVGA].width)
+		&& (height == mt9m114_resolutions[MT9M114_WVGA].height)) {
+		mt9m114_writeregs(client, mt9m114_regs_wvga,
+				ARRAY_SIZE(mt9m114_regs_wvga));
+		mt9m114_read16(client,
+			MT9M114_CAM_SENSOR_CONTROL_READ_MODE, &read_mode);
+		read_mode &= 0xfccf;
+		mt9m114_write16(client,
+			MT9M114_CAM_SENSOR_CONTROL_READ_MODE, read_mode);
+	} else if ((width == mt9m114_resolutions[MT9M114_720P].width)
+		&& (height == mt9m114_resolutions[MT9M114_720P].height)) {
+		mt9m114_writeregs(client, mt9m114_regs_720p,
+				ARRAY_SIZE(mt9m114_regs_720p));
+		mt9m114_read16(client,
+			MT9M114_CAM_SENSOR_CONTROL_READ_MODE, &read_mode);
+		read_mode &= 0xfccf;
+		mt9m114_write16(client,
+			MT9M114_CAM_SENSOR_CONTROL_READ_MODE, read_mode);
+	} else {
+		v4l_err(client, "Failed to select resolution!\n");
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int mt9m114_set_state(struct i2c_client *client, u8 next_state)
+{
+	int timeout = 100, ret;
+	u16 command;
+
+	/* set the next desired state */
+	ret = mt9m114_write8(client, MT9M114_SYSMGR_NEXT_STATE, next_state);
+	if (ret < 0)
+		return ret;
+
+	/* start state transition */
+	ret = mt9m114_write16(client, MT9M114_COMMAND_REGISTER,
+			(MT9M114_COMMAND_REGISTER_OK
+			 | MT9M114_COMMAND_REGISTER_SET_STATE));
+	if (ret < 0)
+		return ret;
+
+	/* wait for the state transition to complete */
+	while (timeout) {
+		ret = mt9m114_read16(client,
+				MT9M114_COMMAND_REGISTER, &command);
+		if (ret < 0)
+			return ret;
+		if (!(command & MT9M114_COMMAND_REGISTER_SET_STATE))
+			break;
+		msleep(10);
+		timeout--;
+	}
+	if (!timeout) {
+		v4l_err(client, "Failed to poll command register\n");
+		return -ETIMEDOUT;
+	}
+
+	/* check if the command is successful */
+	ret = mt9m114_read16(client,
+			MT9M114_COMMAND_REGISTER, &command);
+	if (ret < 0)
+		return ret;
+	if (command & MT9M114_COMMAND_REGISTER_OK)
+		return 0;
+	else
+		return -EFAULT;
+}
+
+
+//////////////////////////////////////////
+//////////////////////////////////////////
+///////////// New code ///////////////////
+
+/*
+ * The default register settings. There
+ * is really no making sense of most of these - lots of "reserved" values
+ * and such.
+ * FIXME this might be a leftover from the old omnivision driver?!
+ * These settings give VGA YUYV.
+ */
+
+struct regval_list {
+  u16 reg_num;
+  u16 size;
+  u32 value;
+};
+
+static struct regval_list pga_regs[] = {
+  { 0x098E, 2, 0},
+  { 0xC95E, 2, 3},
+  { 0xC95E, 2, 2},
+  { 0x3640, 2, 368},
+  { 0x3642, 2, 3787},
+  { 0x3644, 2, 22480},
+  { 0x3646, 2, 33549},
+  { 0x3648, 2, 62062},
+  { 0x364A, 2, 32303},
+  { 0x364C, 2, 18603},
+  { 0x364E, 2, 26192},
+  { 0x3650, 2, 52556},
+  { 0x3652, 2, 44686},
+  { 0x3654, 2, 32431},
+  { 0x3656, 2, 23244},
+  { 0x3658, 2, 7056},
+  { 0x365A, 2, 64140},
+  { 0x365C, 2, 37614},
+  { 0x365E, 2, 32207},
+  { 0x3660, 2, 19178},
+  { 0x3662, 2, 26800},
+  { 0x3664, 2, 45101},
+  { 0x3666, 2, 43151},
+  { 0x3680, 2, 13964},
+  { 0x3682, 2, 1869},
+  { 0x3684, 2, 9871},
+  { 0x3686, 2, 32394},
+  { 0x3688, 2, 38832},
+  { 0x368A, 2, 492},
+  { 0x368C, 2, 2894},
+  { 0x368E, 2, 4687},
+  { 0x3690, 2, 45006},
+  { 0x3692, 2, 34192},
+  { 0x3694, 2, 973},
+  { 0x3696, 2, 2349},
+  { 0x3698, 2, 25323},
+  { 0x369A, 2, 41294},
+  { 0x369C, 2, 46959},
+  { 0x369E, 2, 3405},
+  { 0x36A0, 2, 47531},
+  { 0x36A2, 2, 38860},
+  { 0x36A4, 2, 22506},
+  { 0x36A6, 2, 37359},
+  { 0x36C0, 2, 3569},
+  { 0x36C2, 2, 36620},
+  { 0x36C4, 2, 30224},
+  { 0x36C6, 2, 11116},
+  { 0x36C8, 2, 42739},
+  { 0x36CA, 2, 1681},
+  { 0x36CC, 2, 61514},
+  { 0x36CE, 2, 13265},
+  { 0x36D0, 2, 44462},
+  { 0x36D2, 2, 51635},
+  { 0x36D4, 2, 23184},
+  { 0x36D6, 2, 39789},
+  { 0x36D8, 2, 22480},
+  { 0x36DA, 2, 3885},
+  { 0x36DC, 2, 64882},
+  { 0x36DE, 2, 3505},
+  { 0x36E0, 2, 46314},
+  { 0x36E2, 2, 26864},
+  { 0x36E4, 2, 36813},
+  { 0x36E6, 2, 41555},
+  { 0x3700, 2, 1325},
+  { 0x3702, 2, 60557},
+  { 0x3704, 2, 46961},
+  { 0x3706, 2, 13199},
+  { 0x3708, 2, 25234},
+  { 0x370A, 2, 10253},
+  { 0x370C, 2, 36912},
+  { 0x370E, 2, 46449},
+  { 0x3710, 2, 17713},
+  { 0x3712, 2, 19282},
+  { 0x3714, 2, 10509},
+  { 0x3716, 2, 53295},
+  { 0x3718, 2, 38417},
+  { 0x371A, 2, 8881},
+  { 0x371C, 2, 26834},
+  { 0x371E, 2, 27981},
+  { 0x3720, 2, 39469},
+  { 0x3722, 2, 34321},
+  { 0x3724, 2, 5232},
+  { 0x3726, 2, 20978},
+  { 0x3740, 2, 35307},
+  { 0x3742, 2, 49806},
+  { 0x3744, 2, 62036},
+  { 0x3746, 2, 23250},
+  { 0x3748, 2, 27830},
+  { 0x374A, 2, 8111},
+  { 0x374C, 2, 51085},
+  { 0x374E, 2, 33653},
+  { 0x3750, 2, 24914},
+  { 0x3752, 2, 29270},
+  { 0x3754, 2, 5133},
+  { 0x3756, 2, 5933},
+  { 0x3758, 2, 52436},
+  { 0x375A, 2, 13362},
+  { 0x375C, 2, 18166},
+  { 0x375E, 2, 37550},
+  { 0x3760, 2, 39566},
+  { 0x3762, 2, 61300},
+  { 0x3764, 2, 23602},
+  { 0x3766, 2, 26198},
+  { 0x3782, 2, 480},
+  { 0x3784, 2, 672},
+  { 0xC960, 2, 2800},
+  { 0xC962, 2, 31149},
+  { 0xC964, 2, 22448},
+  { 0xC966, 2, 30936},
+  { 0xC968, 2, 29792},
+  { 0xC96A, 2, 4000},
+  { 0xC96C, 2, 33143},
+  { 0xC96E, 2, 33116},
+  { 0xC970, 2, 33041},
+  { 0xC972, 2, 32855},
+  { 0xC974, 2, 6500},
+  { 0xC976, 2, 31786},
+  { 0xC978, 2, 26268},
+  { 0xC97A, 2, 32319},
+  { 0xC97C, 2, 29650},
+  { 0xC95E, 2, 3},
+  { 0xffff, 0xffff ,0xffff}
+};
+
+static struct regval_list ccm_awb_regs[] = {
+  { 0xC892, 2, 615},
+  { 0xC894, 2, 65306},
+  { 0xC896, 2, 65459},
+  { 0xC898, 2, 65408},
+  { 0xC89A, 2, 358},
+  { 0xC89C, 2, 3},
+  { 0xC89E, 2, 65434},
+  { 0xC8A0, 2, 65204},
+  { 0xC8A2, 2, 589},
+  { 0xC8A4, 2, 447},
+  { 0xC8A6, 2, 65281},
+  { 0xC8A8, 2, 65523},
+  { 0xC8AA, 2, 65397},
+  { 0xC8AC, 2, 408},
+  { 0xC8AE, 2, 65533},
+  { 0xC8B0, 2, 65434},
+  { 0xC8B2, 2, 65255},
+  { 0xC8B4, 2, 680},
+  { 0xC8B6, 2, 473},
+  { 0xC8B8, 2, 65318},
+  { 0xC8BA, 2, 65523},
+  { 0xC8BC, 2, 65459},
+  { 0xC8BE, 2, 306},
+  { 0xC8C0, 2, 65512},
+  { 0xC8C2, 2, 65498},
+  { 0xC8C4, 2, 65229},
+  { 0xC8C6, 2, 706},
+  { 0xC8C8, 2, 117},
+  { 0xC8CA, 2, 284},
+  { 0xC8CC, 2, 154},
+  { 0xC8CE, 2, 261},
+  { 0xC8D0, 2, 164},
+  { 0xC8D2, 2, 172},
+  { 0xC8D4, 2, 2700},
+  { 0xC8D6, 2, 3850},
+  { 0xC8D8, 2, 6500},
+  { 0xC914, 2, 0},
+  { 0xC916, 2, 0},
+  { 0xC918, 2, 1279},
+  { 0xC91A, 2, 719},
+  { 0xC904, 2, 51},
+  { 0xC906, 2, 64},
+  { 0xC8F2, 1, 3},
+  { 0xC8F3, 1, 2},
+  { 0xC906, 2, 60},
+  { 0xC8F4, 2, 0},
+  { 0xC8F6, 2, 0},
+  { 0xC8F8, 2, 0},
+  { 0xC8FA, 2, 59172},
+  { 0xC8FC, 2, 5507},
+  { 0xC8FE, 2, 8261},
+  { 0xC900, 2, 1023},
+  { 0xC902, 2, 124},
+  { 0xC90C, 1, 128},
+  { 0xC90D, 1, 128},
+  { 0xC90E, 1, 128},
+  { 0xC90F, 1, 136},
+  { 0xC910, 1, 128},
+  { 0xC911, 1, 128},
+  { 0xffff, 0xffff ,0xffff}
+};
+
+
+static struct regval_list uvc_ctrl_regs[] = {
+  { REG_UVC_AE_MODE, 1, 0x02}, //has to be enabled by default, otherwise the camera will never start
+  { REG_UVC_AUTO_WHITE_BALANCE_TEMPERATURE, 1, 0x01},
+  { REG_UVC_AE_PRIORITY, 1, 0x00},
+  { REG_UVC_POWER_LINE_FREQUENCY, 1, 0x02},
+  { REG_UVC_EXPOSURE_TIME, 4, 0x00000001},
+  { REG_UVC_BACKLIGHT_COMPENSATION, 2, 0x0001},
+  { REG_UVC_BRIGHTNESS, 2, 0x0037},
+  { REG_UVC_CONTRAST, 2, 0x0020},
+  { REG_UVC_GAIN, 2, 0x0020},
+  { REG_UVC_HUE, 2, 0x0000},
+  { REG_UVC_SATURATION, 2, 0x0080},
+  { REG_UVC_SHARPNESS, 2, -7},
+  { REG_UVC_GAMMA, 2, 0x00DC},
+  { REG_UVC_WHITE_BALANCE_TEMPERATURE, 2, 0x09C4},
+  { REG_UVC_FRAME_INTERVAL, 4, 0x00000001},
+  { REG_UVC_MANUAL_EXPOSURE, 1, 0x00}, //disable flicker avoidance, allow exposure time to be longer than the frame time.
+  { REG_UVC_FLICKER_AVOIDANCE, 1, 0x00},
+  { REG_UVC_ALGO, 2, 0x0007},
+  { REG_UVC_RESULT_STATUS, 1, 0x00},
+  { 0xffff, 0xffff ,0xffff}
+};
+
+
+/*
+ * Low-level register I/O.
+ */
+
+static int mt9m114_read(struct v4l2_subdev *sd,
+                        u16 reg,
+                        u16 size,
+                        u32 *value)
+{
+  u8 cmd[10];
+
+  struct i2c_client *client = v4l2_get_subdevdata(sd);
+  cmd[0] = reg/256;
+  cmd[1] = reg%256;
+  i2c_master_send(client, cmd, 2); //FIXME these functions return error codes. Check them.
+  i2c_master_recv(client, cmd, size);
+  if( size == 2 )
+  {
+    *value = (((u32)cmd[0])<<8) + cmd[1];
+  }
+  else if( size == 4 )
+  {
+    *value = (((u32)cmd[0])<<24) + (((u32)cmd[1])<<16) +
+             (((u32)cmd[2])<<8)  + (((u32)cmd[3])<<0);
+  }
+  else if( size == 1 )
+  {
+    *value = cmd[0];
+  }
+
+  return 0;
+}
+
+static int mt9m114_read1(struct i2c_client *client,
+                        u16 reg,
+                        u16 size,
+                        u32 *value)
+{
+  u8 cmd[10];
+
+  //struct i2c_client *client = v4l2_get_subdevdata(sd);
+  cmd[0] = reg/256;
+  cmd[1] = reg%256;
+  i2c_master_send(client, cmd, 2); //FIXME these functions return error codes. Check them.
+  i2c_master_recv(client, cmd, size);
+  if( size == 2 )
+  {
+    *value = (((u32)cmd[0])<<8) + cmd[1];
+  }
+  else if( size == 4 )
+  {
+    *value = (((u32)cmd[0])<<24) + (((u32)cmd[1])<<16) +
+             (((u32)cmd[2])<<8)  + (((u32)cmd[3])<<0);
+  }
+  else if( size == 1 )
+  {
+    *value = cmd[0];
+  }
+
+  return 0;
+}
+
+/**
+ * 
+ * @param sd
+ * @param reg
+ * @param size
+ * @param value
+ * @return 0 in case of success. Errno error code otherwise.
+ */
+static int mt9m114_write(struct v4l2_subdev *sd,
+                         u16 reg,
+                         u16 size,
+                         u32 value)
+{
+
+   u8 cmd[10];
+   int index=0;
+   struct i2c_client *client = v4l2_get_subdevdata(sd);
+   int numBytesWritten = 0;
+   
+   cmd[index++] = reg/256;
+   cmd[index++] = reg%256;
+
+   if( size == 2) 
+   {
+     //FIXME this breaks signedness.
+     cmd[index++] = value/256;
+     cmd[index++] = value%256;
+   }
+   else if( size == 4)
+   {
+     cmd[index++] = value>>24 & 0xff;
+     cmd[index++] = value>>16 & 0xff;
+     cmd[index++] = value>>8   & 0xff;
+     cmd[index++] = value>>0   & 0xff;
+   }
+   else if( size == 1)
+   {
+     cmd[index++] = value;
+   }
+   
+   numBytesWritten = i2c_master_send(client, cmd, index); //returns negative errno or the number of bytes written
+
+   if(numBytesWritten != index) //make sure that everything was written
+   {
+     if(numBytesWritten < 0) //error code
+     {
+       numBytesWritten *= -1; //in case of error i2c_master_send returns the negative errno.
+       dprintk(0,"MT9M114","MT9M114 : i2c send failed. Error code: 0x%x\n", numBytesWritten);
+       return numBytesWritten;
+     }
+     else
+     {
+       dprintk(0,"MT9M114","MT9M114 : i2c send failed. Wrote %i bytes but should have written %i bytes\n", numBytesWritten, index);
+       return EIO;
+     }
+   }
+   else
+   {
+     return 0;
+   }
+}
+
+/**
+ * 
+ * @param client
+ * @param reg
+ * @param size
+ * @param value
+ * @return 0 in case of success. Errno error code otherwise.
+ */
+static int mt9m114_write1(struct i2c_client *client,
+                         u16 reg,
+                         u16 size,
+                         u32 value)
+{
+
+   u8 cmd[10];
+   int index=0;
+   int numBytesWritten = 0;
+   
+   cmd[index++] = reg/256;
+   cmd[index++] = reg%256;
+
+   if( size == 2) 
+   {
+     //FIXME this breaks signedness.
+     cmd[index++] = value/256;
+     cmd[index++] = value%256;
+   }
+   else if( size == 4)
+   {
+     cmd[index++] = value>>24 & 0xff;
+     cmd[index++] = value>>16 & 0xff;
+     cmd[index++] = value>>8   & 0xff;
+     cmd[index++] = value>>0   & 0xff;
+   }
+   else if( size == 1)
+   {
+     cmd[index++] = value;
+   }
+   
+   numBytesWritten = i2c_master_send(client, cmd, index); //returns negative errno or the number of bytes written
+
+   if(numBytesWritten != index) //make sure that everything was written
+   {
+     if(numBytesWritten < 0) //error code
+     {
+       numBytesWritten *= -1; //in case of error i2c_master_send returns the negative errno.
+       dprintk(0,"MT9M114","MT9M114 : i2c send failed. Error code: 0x%x\n", numBytesWritten);
+       return numBytesWritten;
+     }
+     else
+     {
+       dprintk(0,"MT9M114","MT9M114 : i2c send failed. Wrote %i bytes but should have written %i bytes\n", numBytesWritten, index);
+       return EIO;
+     }
+   }
+   else
+   {
+     return 0;
+   }
+}
+
+#define MAX_MASTER_WRITE 48
+
+static int mt9m114_burst_write1(struct i2c_client *client,
+                               u16 reg,
+                               u16 * array,
+                               u16 size)
+{
+  int i=0;
+  int index=0, abs_index=0;
+  int packet_size=0;
+  u8 cmd[255];
+
+  //struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+  while(size)
+  {
+    if (size >= MAX_MASTER_WRITE){
+      packet_size = MAX_MASTER_WRITE;
+    }
+    else{
+      packet_size = size;
+    }
+    size -= packet_size;
+    index = 0;
+    cmd[index++] = reg/256;
+    cmd[index++] = reg%256;
+    for (i = 0;i < packet_size; i++)
+    {
+      u16 val = array[abs_index++];
+      cmd[index++] = val / 256;
+      cmd[index++] = val % 256;
+      reg +=2;
+    }
+    i2c_master_send(client, cmd, index);
+  }
+  return 0;
+}
+
+/*
+ * Write a list of register settings; ff/ff stops the process.
+ */
+static int mt9m114_write_array(struct i2c_client *client, struct regval_list *vals)
+{
+  int i=0;
+
+  while ((vals[i].reg_num != 0xffff) || (vals[i].value != 0xffff)) {
+    int ret = mt9m114_write1(client, vals[i].reg_num, vals[i].size, vals[i].value);
+    if (ret < 0)
+    {
+      return ret;
+    }
+    i++;
+  }
+  return 0;
+}
+
+/**
+ * 
+ * @param sd
+ * @param bit_mask
+ * @return 0 if everything is ok, 1 otherwise
+ */
+static int poll_command_register_bit(struct v4l2_subdev *sd, u16 bit_mask)
+{
+  int i=0;
+  u32 v=0;
+
+  for (i = 0; i < 1000; i++)
+  {
+    msleep(10);
+    mt9m114_read(sd, REG_COMMAND_REGISTER, 2, &v);
+    if (!(v & bit_mask))
+    {
+      return 0;
+    }
+  }
+  return 1;
+}
+
+/**
+ * 
+ * @param sd
+ * @param bit_mask
+ * @return 0 if everything is ok, 1 otherwise
+ */
+static int poll_command_register_bit1(struct i2c_client *client, u16 bit_mask)
+{
+  int i=0;
+  u32 v=0;
+
+  for (i = 0; i < 1000; i++)
+  {
+    msleep(10);
+    mt9m114_read1(client, REG_COMMAND_REGISTER, 2, &v);
+    if (!(v & bit_mask))
+    {
+      return 0;
+    }
+  }
+  return 1;
+}
+
+/**
+ * Waits until a number of frames have passed
+ * This method can be used to wait for vertical blanking as vertical blanking 
+ * occurs at the end of a frame.
+ * @param sd
+ * @param numFrames the number of frames to wait
+ * @return -1 in case of error, 0 otherwise.
+ */
+static int mt9m114_wait_num_frames(struct v4l2_subdev *sd, u16 numFrames)
+{
+    //FIXME copy & paste from set_state_command
+    u32 v=0;
+    u32 frameCountBefore = 0;
+    u32 frameCountAfter = 0;
+    
+    //get the current frame count
+    mt9m114_read(sd, CAM_MON_HEARTBEAT, 2, &frameCountBefore);
+    
+    
+    //specify for which event we want to wait:  2 = start of next frame
+    mt9m114_write(sd, REG_CMD_HANDLER_WAIT_FOR_EVENT, 2, 2);
+
+    //specify for how much frames we want to wait
+    mt9m114_write(sd, REG_CMD_HANDLER_NUM_WAIT_EVENTS, 2, numFrames);
+   
+    // (Optional) First check that the FW is ready to accept a new command
+    mt9m114_read(sd, REG_COMMAND_REGISTER, 2, &v);
+    if (v & HOST_COMMAND_WAIT_FOR_EVENT)
+    {
+      //This should never happen as long as nobody opens the driver device in async mode.
+      dprintk(0,"MT9M114","MT9M114 : Host command wait for event already set 0x%x\n",v);
+      return -1;
+    }
+    // (Mandatory) Issue the wait for command
+    // We set the 'OK' bit so we can detect if the command fails. The chip will unset the OK bit if everything is ok.
+    mt9m114_write(sd, REG_COMMAND_REGISTER, 2, HOST_COMMAND_WAIT_FOR_EVENT | HOST_COMMAND_OK);
+    // Wait for the FW to complete the command (clear the HOST_COMMAND_1 bit)
+    poll_command_register_bit(sd, HOST_COMMAND_WAIT_FOR_EVENT);
+    // Check the 'OK' bit to see if the command was successful
+    mt9m114_read(sd, REG_COMMAND_REGISTER, 2, &v);
+    if ( !(v & HOST_COMMAND_OK))
+    {
+      dprintk(0,"MT9M114","MT9M114 : wait for end of frame failed: TIMEOUT?!");
+      return -1;
+    }
+    
+    //read frame count after
+    mt9m114_read(sd, CAM_MON_HEARTBEAT, 2, &frameCountAfter);
+    
+    if(frameCountBefore == frameCountAfter)
+    {
+      dprintk(0,"MT9M114","MT9M114 : wait for end of frame failed. Frame is still the same.");
+    }
+    
+    return 0;
+}
+
+/**
+ * Refresh subsystems without requiring a sensor configuration change.
+ * @note This call blocks till the next frame.
+ * @param sd
+ * @return 
+ */
+static int mt9m114_refresh(struct v4l2_subdev *sd)
+{
+  u32 v=0;//a temporary variable used for several read commands
+  
+  //make sure that the refresh command is really processed and that 
+  //exposure and user changes are processed as well.
+  mt9m114_read(sd, REG_UVC_ALGO, 2, &v);
+  v |= 0b111;
+  mt9m114_write(sd, REG_UVC_ALGO,2, v);
+  //Changes to REG_UVC_ALGO take effect on vertical blanking, therefore wait one frame.
+  mt9m114_wait_num_frames(sd, 1);
+  
+  // First check that the FW is ready to accept a Refresh command
+  mt9m114_read(sd, REG_COMMAND_REGISTER, 2, &v);
+  if (v & HOST_COMMAND_REFRESH)
+  {
+    dprintk(0,"MT9M114","MT9M114 : Refresh cmd bit is already set 0x%x\n",v);
+    return -1;
+  }
+
+  // Issue the Refresh command, and set the 'OK' bit at the time time so
+  //we can detect if the command fails
+  mt9m114_write(sd, REG_COMMAND_REGISTER, 2, HOST_COMMAND_REFRESH|HOST_COMMAND_OK);
+
+  // Wait for the FW to complete the command
+  poll_command_register_bit(sd,HOST_COMMAND_REFRESH);
+
+  // Check the 'OK' bit to see if the command was successful
+  mt9m114_read(sd, REG_COMMAND_REGISTER, 2, &v);
+  if ( !(v & HOST_COMMAND_OK))
+  {
+    dprintk(0,"MT9M114","MT9M114 : refresh command fail");
+    return -1;
+  }
+
+  //check refresh command error code
+  mt9m114_read(sd, REG_SEQ_ERROR_CODE, 1, &v);
+  if(v != 0)
+  {
+    dprintk(0,"MT9M114","%s Refresh ERROR: %x\n",__func__, v);
+  }
+  
+  
+  mt9m114_read(sd, REG_UVC_RESULT_STATUS, 1, &v);
+  check_uvc_status(sd, __func__);
+  //dprintk(0,"MT9M114","%s REG_UVC_RESULT_STATUS: %x\n",__func__, v);
+
+  
+  //the refresh command schedules an update on the next end of frame.
+  //It does not wait until the end of frame is actually reached.
+  //Therefore we need to wait until the end of the frame manually.
+  mt9m114_wait_num_frames(sd, 1);
+  
+  
+  return 0;
+}
+
+
+/**
+ * Indicate that uvc and cam variables have gone out of sync.
+ */
+static void mt9m114_uvc_out_of_sync(struct mt9m114 *sensor) 
+{
+	int i;
+    for(i = 0; i < NUM_OF_UVC_REGISTERS; ++i)
+    {
+        sensor->uvc_register_out_of_sync[i] = true;
+    }
+}
+
+/**
+ * Sets the specified uvc register to synced.
+ * @param sd
+ * @param reg
+ */
+static void mt9m114_set_uvc_register_synced(struct v4l2_subdev *sd, uvc_registers reg)
+{
+  struct mt9m114 *sensor = to_mt9m114(sd);
+  sensor->uvc_register_out_of_sync[reg] = false;   
+}
+
+/**
+ * Checks whether the specified uvc register is currently synced.
+ * @param sd
+ * @param reg
+ * @return  true if it is synced.
+ */
+static bool mt9m114_uvc_register_is_out_of_sync(struct v4l2_subdev *sd, uvc_registers reg)
+{
+  struct mt9m114 *sensor = to_mt9m114(sd);
+  return sensor->uvc_register_out_of_sync[reg];
+}
+
+/**
+ * Reads the uvc_result_status register. 
+ * If it contains an error the error is printed to dmesg together with funcName.
+ * 
+ * @note uvc_result_status updates on vertical blanking. Therefore it might not
+ *       contain the correct value if you do not wait until vertical blanking.
+ * @param sd
+ * @param funcName Name of the calling function.
+ * @return In case of error: The errno code or -1 if the error code is unknown. 0 Otherwise.
+ */
+static int check_uvc_status(struct v4l2_subdev *sd, const char* funcName)
+{
+  int result;
+  mt9m114_read(sd, REG_UVC_RESULT_STATUS, 1, &result);
+  
+  
+  /* uvc_result_status can contain the following error codes:
+     0x00 ENOERR no error - change was accepted and actioned.
+     0x08 EACCES permission denied.
+     0x09 EBUSY entity busy, cannot support operation.
+     0x0C EINVAL invalid argument.
+     0x0E ERANGE parameter out-of-range.
+     0x0F ENOSYS operation not supported.
+   */
+  switch(result)
+  {
+    case 0: //no error
+      dprintk(0,"MT9M114","%s REG_UVC_RESULT_STATUS: ENOERR\n", funcName);
+      return 0;
+    case 0x08: //EACCES
+      dprintk(0,"MT9M114","%s REG_UVC_RESULT_STATUS: EACCES\n", funcName);
+      return EACCES;
+    case 0x09: //EBUSY
+      dprintk(0,"MT9M114","%s REG_UVC_RESULT_STATUS: EBUSY\n", funcName);
+      return EBUSY;
+    case 0x0C: //EINVAL
+      dprintk(0,"MT9M114","%s REG_UVC_RESULT_STATUS: EINVAL\n", funcName);
+      return EINVAL;
+    case 0x0E: //ERANGE
+      dprintk(0,"MT9M114","%s REG_UVC_RESULT_STATUS: ERANGE\n", funcName);
+      return ERANGE;
+    case 0x0F: //ENOSYS
+      dprintk(0,"MT9M114","%s REG_UVC_RESULT_STATUS: ENOSYS\n", funcName);
+      return ENOSYS;
+    default:
+      dprintk(0,"MT9M114","%s REG_UVC_RESULT_STATUS: Unknown error code\n", funcName);
+      return -1;
+  }
+}
+
+static int mt9m114_s_brightness(struct v4l2_subdev *sd, u32 value)
+{
+	int ret = 0;
+
+	ret = mt9m114_write(sd, REG_UVC_BRIGHTNESS, 2, value); 
+
+	if(0 != ret)
+	{
+		dprintk(0,"MT9M114","MT9M114 : %s error writing value. errno: 0x%x\n", __func__, ret);
+		return ret;
+	}
+
+	mt9m114_refresh(sd);
+	return ret;
+} 
+
+static int mt9m114_s_auto_white_balance(struct v4l2_subdev *sd, s32 value)
+{
+	int ret = 0;
+	dprintk(0,"MT9M114","MT9M114 : mt9m114_s_auto_white_balance(value=0x%x)\n", value);
+	if(value==0x01) {
+		//enable awb, disable auto exposure in between awb runs (this is the default)
+		//ret = mt9m114_write(sd, REG_AWB_AWB_MODE, 1, 0x02);
+		ret = mt9m114_write(sd, REG_UVC_AUTO_WHITE_BALANCE_TEMPERATURE, 1, 0x02);
+	}
+	else {
+		//ret = mt9m114_write(sd, REG_AWB_AWB_MODE, 1, 0x00);
+		ret = mt9m114_write(sd, REG_UVC_AUTO_WHITE_BALANCE_TEMPERATURE, 1, 0x00);
+	}
+	if(0 != ret) {
+		dprintk(0,"MT9M114","MT9M114 : %s error writing value. errno: 0x%x\n", __func__, ret);
+		return ret;
+	}
+	
+	mt9m114_refresh(sd);
+
+	return ret;
+} 
+
+static int mt9m114_s_white_balance_temperature(struct v4l2_subdev *sd, s32 value)
+{
+	int ret;
+	u16 reg;
+	u16 addr;
+	int i;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	
+	u16 reg16_list[] = {	0xAC12, 0xAC14, 0xC8C8, 0xC8CA, 0xC8CC, 0xC8CE, 0xC8D0, 0xC8D2, \
+							0xAC00, 0xAC02, \
+							0xC909, 0xC8F0, 0xCC01, 0xCC18, \
+							0xB406, 0xB408, 0xB40A, 0xB40C, 0xB40E, 0xB410, 0xB412, 0xB414, 0xB416 \
+						}; 
+	
+	dprintk(0,"MT9M114","MT9M114 : mt9m114_s_white_balance_temperature(value=0x%x)\n", value);
+	//ret = mt9m114_write(sd, REG_AWB_COL_TEMP, 2, value);
+	ret = mt9m114_write16(client, REG_UVC_WHITE_BALANCE_TEMPERATURE, value);
+	if(0 != ret) {
+		dprintk(0,"MT9M114","MT9M114 : %s error writing value. errno: 0x%x\n", __func__, ret);
+		return ret;
+	}
+	
+	mt9m114_refresh(sd);
+	
+	///// testing ////////
+	for(i=0; i<ARRAY_SIZE(reg16_list); i++){
+		ret = mt9m114_read16(client, reg16_list[i], &reg);
+		if (ret < 0) {
+			printk("%s: Failed to read 0x%x\n", reg16_list[i]);
+		}
+		else{
+			printk("%s: awb_r_gain @0x%x = 0x%x\n", __func__, reg16_list[i], reg);
+		}		
+	}
+
+	//////////////////////
+	
+	return ret;
+}
+
+/**
+ * @note This will overwrite the values of UVC_FRAME_INTERVAL_CONTROL, UVC_EXPOSURE_TIME_ABSOLUTE_CONTROL
+ *       and UVC_GAIN_CONTROL
+ * @param sd
+ * @param value
+ * @return 
+ */
+static int mt9m114_s_auto_exposure(struct v4l2_subdev *sd, int value)
+{
+  int ret = 0;
+  if(value == 0x01) {
+    ret = mt9m114_write(sd, REG_UVC_AE_MODE, 1, 0x01); // Manual
+  }
+  else {
+    ret = mt9m114_write(sd, REG_UVC_AE_MODE, 1, 0x02); // Auto
+    
+  }
+
+  mt9m114_refresh(sd);
+  return ret;
+}
+
+static int mt9m114_s_gain(struct v4l2_subdev *sd, int value)
+{
+	int ret = 0;
+
+	ret = mt9m114_write(sd, REG_UVC_GAIN, 2, value); 
+	if(0 != ret) {
+		dprintk(0,"MT9M114","MT9M114 : %s error writing value. errno: 0x%x\n", __func__, ret);
+		return ret;
+	}
+
+	mt9m114_refresh(sd);
+
+	return ret;
+}
+
+static int mt9m114_s_exposure(struct v4l2_subdev *sd, u32 value)
+{
+	int ret = 0;
+	u32 shiftedValue = value << 2;
+
+    ret = mt9m114_write(sd, REG_UVC_EXPOSURE_TIME, 4, /*value*/shiftedValue); 
+	if(0 != ret) {
+		dprintk(0,"MT9M114","MT9M114 : %s error writing value. errno: 0x%x\n", __func__, ret);
+		return ret;
+	}
+
+	mt9m114_refresh(sd);
+
+  return ret;
+}
+
+static int mt9m114_s_saturation(struct v4l2_subdev* sd, s32 val) 
+{
+ 	int ret = 0;
+
+	ret = mt9m114_write(sd, REG_UVC_SATURATION, 2, val); 
+	if(0 != ret) {
+		dprintk(0,"MT9M114","MT9M114 : %s error writing value. errno: 0x%x\n", __func__, ret);
+		return ret;
+	}
+
+	mt9m114_refresh(sd);
+	
+	return ret;
+}
+
+static int mt9m114_s_sharpness(struct v4l2_subdev *sd, int value)
+{
+	int ret = 0;
+
+	ret = mt9m114_write(sd, REG_UVC_SHARPNESS, 2, value); 
+	if(0 != ret){
+		dprintk(0,"MT9M114","MT9M114 : %s error writing value. errno: 0x%x\n", __func__, ret);
+		return ret;
+	}
+
+	mt9m114_refresh(sd);
+
+	return ret;
+}
+
+static int mt9m114_s_contrast(struct v4l2_subdev *sd, int value)
+{
+   int ret = 0;
+   ret = mt9m114_write(sd, REG_UVC_CONTRAST, 2, value); 
+
+  if(0 != ret)
+  {
+    dprintk(0,"MT9M114","MT9M114 : %s error writing value. errno: 0x%x\n", __func__, ret);
+    return ret;
+  }
+ 
+  mt9m114_refresh(sd);
+
+  return ret;
+  
+}
+
+
+/////
+static int mt9m114_errata_1(struct i2c_client *client)
+{
+  mt9m114_write1(client, REG_SAMP_COL_PUP2, 2, 0xFF39); //no idea, register is undocumented
+  return 0;
+}
+
+#define RESET_REGISTER_MASK_BAD 0x0200
+static int mt9m114_errata_2(struct i2c_client *client)
+{
+  //FIXME this doesn't make sense
+  //bit 2 is reserved and the default value is 0 but it is set to 1.
+  //bit 5 is reserved, default is 0 but it is set to 1
+  //MSB is the actual reset register. No idea why the others are changed.
+  mt9m114_write1(client, REG_RESET_REGISTER, 2, 564); //1000110100
+  return 0;
+}
+
+static int mt9m114_sensor_optimization(struct i2c_client *client)
+{
+  //FIXME all registers used in here are undocumented. No idea about their purpose.
+  //      Maybe some commands for the fpga?
+  mt9m114_write1(client, REG_DAC_TXLO_ROW, 2, 0x8270); 
+  mt9m114_write1(client, REG_DAC_TXLO, 2, 0x8270); 
+  mt9m114_write1(client, REG_DAC_LD_4_5, 2, 0x3605); 
+  mt9m114_write1(client, REG_DAC_LD_6_7, 2, 0x77FF); 
+  mt9m114_write1(client, REG_DAC_ECL, 2, 0xC233); 
+  mt9m114_write1(client, REG_DELTA_DK_CONTROL, 2, 0x87FF);
+  mt9m114_write1(client, REG_COLUMN_CORRECTION, 2, 0x6080); 
+  mt9m114_write1(client, REG_AE_TRACK_MODE, 2, 0x0008); 
+  return 0;
+}
+
+static int mt9m114_reset(struct i2c_client *client, u32 val)
+{
+  u32 v;
+  dprintk(0,"MT9M114","MT9M114 : Resetting chip!\n");
+  mt9m114_read1(client, REG_RESET_AND_MISC_CONTROL, 2, &v);
+  mt9m114_write1(client, REG_RESET_AND_MISC_CONTROL, 2, v|0x01);
+  msleep(100); //FIXME This sleep shouldn't be here according to the documentation
+  mt9m114_write1(client, REG_RESET_AND_MISC_CONTROL, 2, v & (~1));
+  msleep(100); //datasheet documentation
+  mt9m114_errata_2(client);
+  return 0;
+}
+
+static int mt9m114_PLL_settings(struct i2c_client *client)
+{
+  mt9m114_write1(client,REG_LOGICAL_ADDRESS_ACCESS, 2, 0x0000);
+  mt9m114_write1(client,REG_CAM_SYSCTL_PLL_ENABLE, 1, 1); //no idea what it does. 1 is default
+  mt9m114_write1(client,REG_CAM_SYSCTL_PLL_DIVIDER_M_N, 2, 0x0120); //no idea, default is 0x09a0
+  mt9m114_write1(client,REG_CAM_SYSCTL_PLL_DIVIDER_P, 2, /*0x0700*/0x900);//no idea, default is 0x0700
+  mt9m114_write1(client,REG_CAM_SENSOR_CFG_PIXCLK, 4, 0x2DC6C00);
+  
+  return 0;
+}
+
+// Patch 0202; Feature Recommended; Black level correction fix
+static int mt9m114_patch2_black_lvl_correction_fix(struct i2c_client *client)
+{
+  u32 v=0;
+
+  u16 reg_burst[] = {
+    0x70cf, 0xffff, 0xc5d4, 0x903a, 0x2144, 0x0c00, 0x2186, 0x0ff3,
+    0xb844, 0xb948, 0xe082, 0x20cc, 0x80e2, 0x21cc, 0x80a2, 0x21cc,
+    0x80e2, 0xf404, 0xd801, 0xf003, 0xd800, 0x7ee0, 0xc0f1, 0x08ba,
+    0x0600, 0xc1a1, 0x76cf, 0xffff, 0xc130, 0x6e04, 0xc040, 0x71cf,
+    0xffff, 0xc790, 0x8103, 0x77cf, 0xffff, 0xc7c0, 0xe001, 0xa103,
+    0xd800, 0x0c6a, 0x04e0, 0xb89e, 0x7508, 0x8e1c, 0x0809, 0x0191,
+    0xd801, 0xae1d, 0xe580, 0x20ca, 0x0022, 0x20cf, 0x0522, 0x0c5c,
+    0x04e2, 0x21ca, 0x0062, 0xe580, 0xd901, 0x79c0, 0xd800, 0x0be6,
+    0x04e0, 0xb89e, 0x70cf, 0xffff, 0xc8d4, 0x9002, 0x0857, 0x025e,
+    0xffdc, 0xe080, 0x25cc, 0x9022, 0xf225, 0x1700, 0x108a, 0x73cf,
+    0xff00, 0x3174, 0x9307, 0x2a04, 0x103e, 0x9328, 0x2942, 0x7140,
+    0x2a04, 0x107e, 0x9349, 0x2942, 0x7141, 0x2a04, 0x10be, 0x934a,
+    0x2942, 0x714b, 0x2a04, 0x10be, 0x130c, 0x010a, 0x2942, 0x7142,
+    0x2250, 0x13ca, 0x1b0c, 0x0284, 0xb307, 0xb328, 0x1b12, 0x02c4,
+    0xb34a, 0xed88, 0x71cf, 0xff00, 0x3174, 0x9106, 0xb88f, 0xb106,
+    0x210a, 0x8340, 0xc000, 0x21ca, 0x0062, 0x20f0, 0x0040, 0x0b02,
+    0x0320, 0xd901, 0x07f1, 0x05e0, 0xc0a1, 0x78e0, 0xc0f1, 0x71cf,
+    0xffff, 0xc7c0, 0xd840, 0xa900, 0x71cf, 0xffff, 0xd02c, 0xd81e,
+    0x0a5a, 0x04e0, 0xda00, 0xd800, 0xc0d1, 0x7ee0
+  };
+
+  mt9m114_write1(client, REG_ACCESS_CTL_STAT, 2, 0x0001);
+  mt9m114_write1(client, REG_PHYSICAL_ADDRESS_ACCESS, 2, 0x5000);
+  mt9m114_burst_write1(client,0xd000, reg_burst, ARRAY_SIZE(reg_burst));
+  mt9m114_write1(client, REG_LOGICAL_ADDRESS_ACCESS, 2, 0x0000);
+  mt9m114_write1(client, REG_PATCHLDR_LOADER_ADDRESS, 2, 0x010c);
+  mt9m114_write1(client, REG_PATCHLDR_PATCH_ID, 2, 0x0202);
+  mt9m114_write1(client, REG_PATCHLDR_FIRMWARE_ID, 4, 0x41030202);
+
+  mt9m114_write1(client, REG_COMMAND_REGISTER, 2, HOST_COMMAND_OK);
+  v = HOST_COMMAND_OK | HOST_COMMAND_APPLY_PATCH;
+  mt9m114_write1(client, REG_COMMAND_REGISTER, 2, v);
+
+  if(poll_command_register_bit1(client,HOST_COMMAND_APPLY_PATCH))
+  {
+    dprintk(0,"MT9M114","poll apply patch timeout\n");
+  }
+
+  mt9m114_read1(client, REG_COMMAND_REGISTER, 2, &v);
+  if ( !(v & HOST_COMMAND_OK))
+  {
+    dprintk(0,"MT9M114","Warning : apply patch 2 Black level correction fix Host_command not OK\n");
+  }
+
+  mt9m114_read1(client, REG_PATCHLDR_APPLY_STATUS, 1, &v);
+  if (v)
+  {
+    dprintk(0,"MT9M114","MT9M114 : patch apply 2 Black level correction fix status non-zero  - value:%x\n",v);
+    return -1;
+  }
+
+  return 0;
+}
+
+
+
+//
+// Patch 03 - Feature request, Adaptive Sensitivity.
+//
+// This patch implements the new feature VGA auto binning mode. This was a
+// request to support automatic mode transition between VGA scaled and binning
+// mode (and back)
+//
+// To support this feature a new Firmware variable page has been added which
+// controls this functionality as well as hold configuration parameters for
+// the automatic binning mode of operation. This pasge needs to be configured
+// correctly as these values will be used to populate the CAM page during the
+// switch
+//
+//
+// Main control variables
+//     AUTO_BINNING_MODE.AUTO_BINNING_MODE_ENABLE:
+//         Controls automatic binning mode (0=disabled, 1=enabled).
+//         NOTE: Requires Change-Congig to apply
+//     AUTO_BINNING_STATUS.AUTO_BINNING_STATUS_ENABLE
+//         Current enable/disable state of automatic binning mode (0=disabled, 1=enabled)
+//     AUTO_BINNING_THRESHOLD_BM
+//         Switching threshold in terms of inverse brightness metric (ufixed8)
+//     AUTO_BINNING_GATE_PERCENTAGE
+//         Gate width as a percentage of threshold
+//
+// Notes:
+//     CAM_LL_SUMMING_SENSITIVITY_FACTOR
+//         This is the sensitivity gain that is achieved when sub-sampled
+//         read mode is selected, summing or average (approximately 2.0x
+//         unity=32)
+//
+//     The sensitivity factor and gate width must be tuned correctly to avoid
+//     oscillation during the switch
+
+static int mt9m114_patch3_adaptive_sensitivity(struct i2c_client *client)
+{
+  u32 v=0;
+  u16 reg_burst[] = {
+    0x70cf, 0xffff, 0xc5d4, 0x903a, 0x2144, 0x0c00, 0x2186, 0x0ff3,
+    0xb844, 0x262f, 0xf008, 0xb948, 0x21cc, 0x8021, 0xd801, 0xf203,
+    0xd800, 0x7ee0, 0xc0f1, 0x71cf, 0xffff, 0xc610, 0x910e, 0x208c,
+    0x8014, 0xf418, 0x910f, 0x208c, 0x800f, 0xf414, 0x9116, 0x208c,
+    0x800a, 0xf410, 0x9117, 0x208c, 0x8807, 0xf40c, 0x9118, 0x2086,
+    0x0ff3, 0xb848, 0x080d, 0x0090, 0xffea, 0xe081, 0xd801, 0xf203,
+    0xd800, 0xc0d1, 0x7ee0, 0x78e0, 0xc0f1, 0x71cf, 0xffff, 0xc610,
+    0x910e, 0x208c, 0x800a, 0xf418, 0x910f, 0x208c, 0x8807, 0xf414,
+    0x9116, 0x208c, 0x800a, 0xf410, 0x9117, 0x208c, 0x8807, 0xf40c,
+    0x9118, 0x2086, 0x0ff3, 0xb848, 0x080d, 0x0090, 0xffd9, 0xe080,
+    0xd801, 0xf203, 0xd800, 0xf1df, 0x9040, 0x71cf, 0xffff, 0xc5d4,
+    0xb15a, 0x9041, 0x73cf, 0xffff, 0xc7d0, 0xb140, 0x9042, 0xb141,
+    0x9043, 0xb142, 0x9044, 0xb143, 0x9045, 0xb147, 0x9046, 0xb148,
+    0x9047, 0xb14b, 0x9048, 0xb14c, 0x9049, 0x1958, 0x0084, 0x904a,
+    0x195a, 0x0084, 0x8856, 0x1b36, 0x8082, 0x8857, 0x1b37, 0x8082,
+    0x904c, 0x19a7, 0x009c, 0x881a, 0x7fe0, 0x1b54, 0x8002, 0x78e0,
+    0x71cf, 0xffff, 0xc350, 0xd828, 0xa90b, 0x8100, 0x01c5, 0x0320,
+    0xd900, 0x78e0, 0x220a, 0x1f80, 0xffff, 0xd4e0, 0xc0f1, 0x0811,
+    0x0051, 0x2240, 0x1200, 0xffe1, 0xd801, 0xf006, 0x2240, 0x1900,
+    0xffde, 0xd802, 0x1a05, 0x1002, 0xfff2, 0xf195, 0xc0f1, 0x0e7e,
+    0x05c0, 0x75cf, 0xffff, 0xc84c, 0x9502, 0x77cf, 0xffff, 0xc344,
+    0x2044, 0x008e, 0xb8a1, 0x0926, 0x03e0, 0xb502, 0x9502, 0x952e,
+    0x7e05, 0xb5c2, 0x70cf, 0xffff, 0xc610, 0x099a, 0x04a0, 0xb026,
+    0x0e02, 0x0560, 0xde00, 0x0a12, 0x0320, 0xb7c4, 0x0b36, 0x03a0,
+    0x70c9, 0x9502, 0x7608, 0xb8a8, 0xb502, 0x70cf, 0x0000, 0x5536,
+    0x7860, 0x2686, 0x1ffb, 0x9502, 0x78c5, 0x0631, 0x05e0, 0xb502,
+    0x72cf, 0xffff, 0xc5d4, 0x923a, 0x73cf, 0xffff, 0xc7d0, 0xb020,
+    0x9220, 0xb021, 0x9221, 0xb022, 0x9222, 0xb023, 0x9223, 0xb024,
+    0x9227, 0xb025, 0x9228, 0xb026, 0x922b, 0xb027, 0x922c, 0xb028,
+    0x1258, 0x0101, 0xb029, 0x125a, 0x0101, 0xb02a, 0x1336, 0x8081,
+    0xa836, 0x1337, 0x8081, 0xa837, 0x12a7, 0x0701, 0xb02c, 0x1354,
+    0x8081, 0x7fe0, 0xa83a, 0x78e0, 0xc0f1, 0x0dc2, 0x05c0, 0x7608,
+    0x09bb, 0x0010, 0x75cf, 0xffff, 0xd4e0, 0x8d21, 0x8d00, 0x2153,
+    0x0003, 0xb8c0, 0x8d45, 0x0b23, 0x0000, 0xea8f, 0x0915, 0x001e,
+    0xff81, 0xe808, 0x2540, 0x1900, 0xffde, 0x8d00, 0xb880, 0xf004,
+    0x8d00, 0xb8a0, 0xad00, 0x8d05, 0xe081, 0x20cc, 0x80a2, 0xdf00,
+    0xf40a, 0x71cf, 0xffff, 0xc84c, 0x9102, 0x7708, 0xb8a6, 0x2786,
+    0x1ffe, 0xb102, 0x0b42, 0x0180, 0x0e3e, 0x0180, 0x0f4a, 0x0160,
+    0x70c9, 0x8d05, 0xe081, 0x20cc, 0x80a2, 0xf429, 0x76cf, 0xffff,
+    0xc84c, 0x082d, 0x0051, 0x70cf, 0xffff, 0xc90c, 0x8805, 0x09b6,
+    0x0360, 0xd908, 0x2099, 0x0802, 0x9634, 0xb503, 0x7902, 0x1523,
+    0x1080, 0xb634, 0xe001, 0x1d23, 0x1002, 0xf00b, 0x9634, 0x9503,
+    0x6038, 0xb614, 0x153f, 0x1080, 0xe001, 0x1d3f, 0x1002, 0xffa4,
+    0x9602, 0x7f05, 0xd800, 0xb6e2, 0xad05, 0x0511, 0x05e0, 0xd800,
+    0xc0f1, 0x0cfe, 0x05c0, 0x0a96, 0x05a0, 0x7608, 0x0c22, 0x0240,
+    0xe080, 0x20ca, 0x0f82, 0x0000, 0x190b, 0x0c60, 0x05a2, 0x21ca,
+    0x0022, 0x0c56, 0x0240, 0xe806, 0x0e0e, 0x0220, 0x70c9, 0xf048,
+    0x0896, 0x0440, 0x0e96, 0x0400, 0x0966, 0x0380, 0x75cf, 0xffff,
+    0xd4e0, 0x8d00, 0x084d, 0x001e, 0xff47, 0x080d, 0x0050, 0xff57,
+    0x0841, 0x0051, 0x8d04, 0x9521, 0xe064, 0x790c, 0x702f, 0x0ce2,
+    0x05e0, 0xd964, 0x72cf, 0xffff, 0xc700, 0x9235, 0x0811, 0x0043,
+    0xff3d, 0x080d, 0x0051, 0xd801, 0xff77, 0xf025, 0x9501, 0x9235,
+    0x0911, 0x0003, 0xff49, 0x080d, 0x0051, 0xd800, 0xff72, 0xf01b,
+    0x0886, 0x03e0, 0xd801, 0x0ef6, 0x03c0, 0x0f52, 0x0340, 0x0dba,
+    0x0200, 0x0af6, 0x0440, 0x0c22, 0x0400, 0x0d72, 0x0440, 0x0dc2,
+    0x0200, 0x0972, 0x0440, 0x0d3a, 0x0220, 0xd820, 0x0bfa, 0x0260,
+    0x70c9, 0x0451, 0x05c0, 0x78e0, 0xd900, 0xf00a, 0x70cf, 0xffff,
+    0xd520, 0x7835, 0x8041, 0x8000, 0xe102, 0xa040, 0x09f1, 0x8114,
+    0x71cf, 0xffff, 0xd4e0, 0x70cf, 0xffff, 0xc594, 0xb03a, 0x7fe0,
+    0xd800, 0x0000, 0x0000, 0x0500, 0x0500, 0x0200, 0x0330, 0x0000,
+    0x0000, 0x03cd, 0x050d, 0x01c5, 0x03b3, 0x00e0, 0x01e3, 0x0280,
+    0x01e0, 0x0109, 0x0080, 0x0500, 0x0000, 0x0000, 0x0000, 0x0000,
+    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+    0x0000, 0x0000, 0xffff, 0xc9b4, 0xffff, 0xd324, 0xffff, 0xca34,
+    0xffff, 0xd3ec
+  };
+
+  mt9m114_write1(client, REG_ACCESS_CTL_STAT, 2, 0x0001);
+  mt9m114_write1(client, REG_PHYSICAL_ADDRESS_ACCESS, 2, 0x512c);
+  mt9m114_burst_write1(client,0xd12c, reg_burst, ARRAY_SIZE(reg_burst));
+
+  mt9m114_write1(client, REG_LOGICAL_ADDRESS_ACCESS, 2, 0x0000);
+  mt9m114_write1(client, REG_PATCHLDR_LOADER_ADDRESS, 2, 0x04b4);
+  mt9m114_write1(client, REG_PATCHLDR_PATCH_ID, 2, 0x0302);
+  mt9m114_write1(client, REG_PATCHLDR_FIRMWARE_ID, 4, 0x41030202);
+
+  v = HOST_COMMAND_APPLY_PATCH | HOST_COMMAND_OK;
+  mt9m114_write1(client, REG_COMMAND_REGISTER, 2, v);
+
+  if(poll_command_register_bit1(client,HOST_COMMAND_APPLY_PATCH))
+  {
+    dprintk(0,"MT9M114","MT9M114 : poll apply patch timeout\n");
+  }
+
+  mt9m114_read1(client, REG_COMMAND_REGISTER, 2, &v);
+  if ( !(v & HOST_COMMAND_OK))
+  {
+    dprintk(0,"MT9M114","Warning : apply patch 3 Adaptive Sensitivity Host_command not OK\n");
+    return -1;
+  }
+
+  mt9m114_read1(client, REG_PATCHLDR_APPLY_STATUS, 1, &v);
+  if (v)
+  {
+    dprintk(0,"MT9M114","MT9M114 : patch apply 3 Adaptive Sensitivity status non-zero - value:%x\n",v);
+    return -1;
+  }
+
+  return 0;
+}
+
+static int mt9m114_CPIPE_preference(struct i2c_client *client)
+{
+  mt9m114_write1(client, REG_CAM_LL_START_BRIGHTNESS, 2, 0x0020);
+  mt9m114_write1(client, REG_CAM_LL_STOP_BRIGHTNESS, 2, 0x009A);
+  mt9m114_write1(client, REG_CAM_LL_START_GAIN_METRIC, 2, 0x0070);
+  mt9m114_write1(client, REG_CAM_LL_STOP_GAIN_METRIC, 2, 0x00F3);
+
+  mt9m114_write1(client, REG_CAM_LL_START_TARGET_LUMA_BM, 2, 0x0020);
+  mt9m114_write1(client, REG_CAM_LL_STOP_TARGET_LUMA_BM, 2, 0x009A);
+
+  mt9m114_write1(client, REG_CAM_LL_START_SATURATION, 1, 0x80);
+  mt9m114_write1(client, REG_CAM_LL_END_SATURATION, 1, 0x4B);
+  mt9m114_write1(client, REG_CAM_LL_START_DESATURATION, 1, 0x00);
+  mt9m114_write1(client, REG_CAM_LL_END_DESATURATION, 1, 0xFF);
+
+  mt9m114_write1(client, REG_CAM_LL_START_DEMOSAIC, 1, 0x1E);
+  mt9m114_write1(client, REG_CAM_LL_START_AP_GAIN, 1, 0x02);
+  mt9m114_write1(client, REG_CAM_LL_START_AP_THRESH, 1, 0x06);
+  mt9m114_write1(client, REG_CAM_LL_STOP_DEMOSAIC, 1, 0x3C);
+  mt9m114_write1(client, REG_CAM_LL_STOP_AP_GAIN, 1, 0x01);
+  mt9m114_write1(client, REG_CAM_LL_STOP_AP_THRESH, 1, 0x0C);
+
+  mt9m114_write1(client, REG_CAM_LL_START_NR_RED, 1, 0x3C);
+  mt9m114_write1(client, REG_CAM_LL_START_NR_GREEN, 1, 0x3C);
+  mt9m114_write1(client, REG_CAM_LL_START_NR_BLUE, 1, 0x3C);
+  mt9m114_write1(client, REG_CAM_LL_START_NR_THRESH, 1, 0x0F);
+  mt9m114_write1(client, REG_CAM_LL_STOP_NR_RED, 1, 0x64);
+  mt9m114_write1(client, REG_CAM_LL_STOP_NR_GREEN, 1, 0x64);
+  mt9m114_write1(client, REG_CAM_LL_STOP_NR_BLUE, 1, 0x64);
+  mt9m114_write1(client, REG_CAM_LL_STOP_NR_THRESH, 1, 0x32);
+
+  mt9m114_write1(client, REG_CAM_LL_START_CONTRAST_BM, 2, 0x0020);
+  mt9m114_write1(client, REG_CAM_LL_STOP_CONTRAST_BM, 2, 0x009A);
+  mt9m114_write1(client, REG_CAM_LL_GAMMA, 2, 0x00DC);
+  mt9m114_write1(client, REG_CAM_LL_START_CONTRAST_GRADIENT, 1, 0x38);
+  mt9m114_write1(client, REG_CAM_LL_STOP_CONTRAST_GRADIENT, 1, 0x30);
+  mt9m114_write1(client, REG_CAM_LL_START_CONTRAST_LUMA_PERCENTAGE, 1, 0x50);
+  mt9m114_write1(client, REG_CAM_LL_STOP_CONTRAST_LUMA_PERCENTAGE, 1, 0x19);
+
+  mt9m114_write1(client, REG_CAM_LL_START_FADE_TO_BLACK_LUMA, 2, 0x0230);
+  mt9m114_write1(client, REG_CAM_LL_STOP_FADE_TO_BLACK_LUMA, 2, 0x0010);
+
+  mt9m114_write1(client, REG_CAM_LL_CLUSTER_DC_TH_BM, 2, 0x0800);
+
+  mt9m114_write1(client, REG_CAM_LL_CLUSTER_DC_GATE_PERCENTAGE, 1, 0x05);
+
+  mt9m114_write1(client, REG_CAM_LL_SUMMING_SENSITIVITY_FACTOR, 1, 0x40);
+
+  mt9m114_write1(client, REG_CAM_AET_TARGET_AVERAGE_LUMA_DARK, 1, 0x1B);
+
+  mt9m114_write1(client, REG_CAM_AET_AEMODE, 1, 0x0E);
+  mt9m114_write1(client, REG_CAM_AET_TARGET_GAIN, 2, 0x0080);
+  mt9m114_write1(client, REG_CAM_AET_AE_MAX_VIRT_AGAIN, 2, 0x0100);
+  mt9m114_write1(client, REG_CAM_SENSOR_CFG_MAX_ANALOG_GAIN, 2, 0x01F8);
+
+  mt9m114_write1(client, REG_CAM_AET_BLACK_CLIPPING_TARGET, 2, 0x005A);
+
+  mt9m114_write1(client, REG_CCM_DELTA_GAIN, 1, 0x05);
+  mt9m114_write1(client, REG_AE_TRACK_AE_TRACKING_DAMPENING_SPEED, 1, 0x20);
+  return 0;
+}
+
+//////////////////////////////////////////
+//////////////////////////////////////////
+//////////////////////////////////////////
+//////////////////////////////////////////
+
+
+static int mt9m114_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct v4l2_subdev *sd = to_sd(ctrl);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	u16 read_mode;
+
+	switch (ctrl->id) {
+		case V4L2_CID_HFLIP:
+			printk("%s: V4L2_CID_HFLIP %d\n", __func__, ctrl->val); //// testing
+			mt9m114_read16(client, MT9M114_CAM_SENSOR_CONTROL_READ_MODE, &read_mode);
+			read_mode = (read_mode & 0xfffe) | ctrl->val;
+			mt9m114_write16(client, MT9M114_CAM_SENSOR_CONTROL_READ_MODE, read_mode);
+			break;
+			
+		case V4L2_CID_VFLIP:
+			printk("%s: V4L2_CID_VFLIP %d\n", __func__, ctrl->val); //// testing
+			mt9m114_read16(client, MT9M114_CAM_SENSOR_CONTROL_READ_MODE, &read_mode);
+			read_mode = (read_mode & 0xfffd) | (ctrl->val << 1);
+			mt9m114_write16(client, MT9M114_CAM_SENSOR_CONTROL_READ_MODE, read_mode);
+			break;
+		
+		case V4L2_CID_BRIGHTNESS:
+			printk("%s: V4L2_CID_BRIGHTNESS %d\n", __func__, ctrl->val); //// testing
+			return mt9m114_s_brightness(sd, ctrl->val);
+		
+		case V4L2_CID_AUTO_WHITE_BALANCE:
+			printk("%s: V4L2_CID_AUTO_WHITE_BALANCE %d\n", __func__, ctrl->val); //// testing
+			return mt9m114_s_auto_white_balance(sd, ctrl->val);
+		
+		case V4L2_CID_WHITE_BALANCE_TEMPERATURE:
+			printk("%s: V4L2_CID_WHITE_BALANCE_TEMPERATURE %d\n", __func__, ctrl->val); //// testing
+			return mt9m114_s_white_balance_temperature(sd, ctrl->val);
+
+		case V4L2_CID_EXPOSURE_AUTO:
+			printk("%s: V4L2_CID_EXPOSURE_AUTO 0x%x\n", __func__, ctrl->val);
+			return mt9m114_s_auto_exposure(sd, ctrl->val);
+					
+		case V4L2_CID_GAIN:
+			printk("%s: V4L2_CID_GAIN 0x%x\n", __func__, ctrl->val);
+			return mt9m114_s_gain(sd, ctrl->val);
+		
+		case V4L2_CID_EXPOSURE:
+			printk("%s: V4L2_CID_EXPOSURE 0x%x\n", __func__, ctrl->val);
+			return mt9m114_s_exposure(sd, ctrl->val);			
+		
+		case V4L2_CID_SATURATION:
+			printk("%s: V4L2_CID_SATURATION 0x%x\n", __func__, ctrl->val);
+			return mt9m114_s_saturation(sd, ctrl->val);
+		
+		case V4L2_CID_SHARPNESS:
+			printk("%s: V4L2_CID_SHARPNESS 0x%x\n", __func__, ctrl->val);
+			return mt9m114_s_sharpness(sd, ctrl->val);
+			
+		case V4L2_CID_CONTRAST:
+			printk("%s: V4L2_CID_CONTRAST 0x%x\n", __func__, ctrl->val);
+			return mt9m114_s_contrast(sd, ctrl->val);
+		default:
+			return -EINVAL;
+		}
+
+	return 0;
+}
+
+static int mt9m114_g_parm(struct v4l2_subdev *sd,
+				struct v4l2_streamparm *parms)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct v4l2_captureparm *cp = &parms->parm.capture;
+	u16 frame_rate;
+
+	if (parms->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+		return -EINVAL;
+
+	memset(cp, 0, sizeof(*cp));
+	cp->capability = V4L2_CAP_TIMEPERFRAME;
+	cp->timeperframe.numerator = 1;
+	mt9m114_read16(client, MT9M114_CAM_AET_MAX_FRAME_RATE, &frame_rate);
+	cp->timeperframe.denominator = frame_rate >> 8;
+	return 0;
+}
+
+static int mt9m114_s_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *parms)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct v4l2_captureparm *cp = &parms->parm.capture;
+	struct v4l2_fract *tpf = &cp->timeperframe;
+	u16 frame_rate;
+
+	if (parms->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+		return -EINVAL;
+	if (cp->extendedmode != 0)
+		return -EINVAL;
+
+	if (tpf->numerator == 0 || tpf->denominator == 0
+		|| (tpf->denominator > tpf->numerator * MAX_FRAME_RATE)) {
+		/* reset to max frame rate */
+		tpf->numerator = 1;
+		tpf->denominator = MAX_FRAME_RATE;
+	}
+	frame_rate = (tpf->denominator / tpf->numerator) << 8;
+	mt9m114_write16(client, MT9M114_CAM_AET_MAX_FRAME_RATE, frame_rate);
+	mt9m114_write16(client, MT9M114_CAM_AET_MIN_FRAME_RATE, frame_rate);
+	return 0;
+}
+
+int mt9m114_g_frame_interval(struct v4l2_subdev *sd, struct v4l2_subdev_frame_interval *interval)
+{
+	// TODO: Add code
+	printk("%s : Code not implemented\n", __func__);
+	return 0;
+}
+
+int mt9m114_s_frame_interval(struct v4l2_subdev *sd, struct v4l2_subdev_frame_interval *interval)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct v4l2_fract *tpf = &interval->interval;
+	u16 frame_rate;
+	
+	if (tpf->numerator == 0 || tpf->denominator == 0
+		|| (tpf->denominator > tpf->numerator * MAX_FRAME_RATE)) {
+		/* reset to max frame rate */
+		tpf->numerator = 1;
+		tpf->denominator = MAX_FRAME_RATE;
+	}
+	frame_rate = (tpf->denominator / tpf->numerator) << 8;
+	mt9m114_write16(client, MT9M114_CAM_AET_MAX_FRAME_RATE, frame_rate);
+	mt9m114_write16(client, MT9M114_CAM_AET_MIN_FRAME_RATE, frame_rate);
+	return 0;
+}
+
+static int mt9m114_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+	ret = mt9m114_set_state(client,
+			MT9M114_SYS_STATE_ENTER_CONFIG_CHANGE);
+	if (ret < 0)
+		return ret;
+	if (enable)
+		ret = mt9m114_set_state(client,
+				MT9M114_SYS_STATE_START_STREAMING);
+	else
+		ret = mt9m114_set_state(client,
+				MT9M114_SYS_STATE_ENTER_SUSPEND);
+	return ret;
+}
+
+static const struct v4l2_ctrl_ops mt9m114_ctrl_ops = {
+	.s_ctrl = mt9m114_s_ctrl,
+};
+
+/* -----------------------------------------------------------------------------
+ * V4L2 Subdevice Pad Operations
+ */
+ 
+static struct v4l2_mbus_framefmt *
+__mt9m114_get_pad_format(	struct mt9m114 *sensor, 
+							struct v4l2_subdev_pad_config *cfg,
+							unsigned int pad, 
+							u32 which)
+{
+	if (pad >= sensor->npads)
+		return NULL;
+
+	switch (which) {
+		case V4L2_SUBDEV_FORMAT_TRY:
+			return v4l2_subdev_get_try_format(&sensor->sd, cfg, pad);
+		case V4L2_SUBDEV_FORMAT_ACTIVE:
+			return &sensor->formats[pad];
+		default:
+			return NULL;
+	}
+}
+
+static int mt9m114_try_mbus_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *fmt)
+{
+	int index;
+
+	for (index = 0; index < ARRAY_SIZE(mt9m114_supported_video_formats); index++){
+		if (mt9m114_supported_video_formats[index].mbus_code == fmt->code)
+			break;
+	}		
+			
+	if (index >= ARRAY_SIZE(mt9m114_supported_video_formats)) {
+		/* default to first format */
+		index = 0;
+		fmt->code = mt9m114_supported_video_formats[0].mbus_code;
+	}
+	mt9m114_res_roundup(&fmt->width, &fmt->height);
+
+	fmt->field = V4L2_FIELD_NONE;
+	fmt->colorspace = mt9m114_supported_video_formats[index].colorspace;
+	return 0;
+}
+
+static int mt9m114_s_mbus_fmt(	struct v4l2_subdev *sd,
+								struct v4l2_subdev_pad_config *cfg,
+								struct v4l2_subdev_format *fmt)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct mt9m114 *sensor = to_mt9m114(sd);
+	struct v4l2_mbus_framefmt *fmt_ptr;
+	struct v4l2_mbus_framefmt resp_fmt;
+	u16 output_fmt;
+	int ret;
+	
+	v4l2_dbg(1, debug, sd, "Set format\n");
+	fmt_ptr = __mt9m114_get_pad_format(sensor, cfg, fmt->pad, fmt->which);
+	if (fmt->pad >= sensor->npads || fmt_ptr == NULL)
+		return -EINVAL;
+
+	resp_fmt = fmt->format;
+	mt9m114_try_mbus_fmt(sd, &resp_fmt);
+	/* set image size */
+	ret = mt9m114_set_res(client, resp_fmt.width, resp_fmt.height);
+	if (ret < 0)
+		return ret;
+
+	/* set image format */
+	ret = mt9m114_read16(client, MT9M114_CAM_OUTPUT_FORMAT, &output_fmt);
+	if (ret < 0){
+		return ret;
+	}
+
+	output_fmt &= 0xc0fc;
+	switch (resp_fmt.code) {
+		case MEDIA_BUS_FMT_SGRBG8_1X8:
+		case MEDIA_BUS_FMT_SRGGB8_1X8:
+		case MEDIA_BUS_FMT_SGBRG8_1X8:
+		case MEDIA_BUS_FMT_SBGGR8_1X8:
+			//output_fmt = 0x0200; // Bayer + Raw Bayer 10
+			output_fmt = 0x0E00; // Bayer + Processed8
+			break;
+		case MEDIA_BUS_FMT_YUYV8_2X8:
+			output_fmt |= 0x0002;
+			break;
+		case MEDIA_BUS_FMT_RGB565_2X8_LE:
+			output_fmt |= 0x0102;
+			break;
+		case MEDIA_BUS_FMT_RGB565_2X8_BE:
+			output_fmt |= 0x0100;
+			break;
+		default:
+			return -EINVAL;
+	}
+	ret = mt9m114_write16(client, MT9M114_CAM_OUTPUT_FORMAT, output_fmt);
+	if (ret < 0)
+		return ret;
+
+	// update try/active format
+	*fmt_ptr = resp_fmt;
+	fmt->format = resp_fmt; // response
+	return 0;
+}
+
+static int mt9m114_g_mbus_fmt(	struct v4l2_subdev *sd,
+								struct v4l2_subdev_pad_config *cfg,
+								struct v4l2_subdev_format *fmt)
+{
+	struct v4l2_mbus_framefmt *tfmt;
+	struct mt9m114 *sensor = to_mt9m114(sd);
+
+	v4l2_dbg(1, debug, sd, "Get format\n");
+	tfmt = __mt9m114_get_pad_format(sensor, cfg, fmt->pad, fmt->which);
+	if(tfmt == NULL){
+		return -EINVAL;
+	}
+	fmt->format = *tfmt;
+	
+	v4l2_dbg(1, debug, sd, "width       %d\n", tfmt->width);
+	v4l2_dbg(1, debug, sd, "height      %d\n", tfmt->height);
+	v4l2_dbg(1, debug, sd, "code        %d (0x%x)\n", tfmt->code, tfmt->code);
+	v4l2_dbg(1, debug, sd, "field       %d (0x%x)\n", tfmt->field, tfmt->field);
+	v4l2_dbg(1, debug, sd, "colorspace  %d (0x%x)\n", tfmt->colorspace, tfmt->colorspace);
+
+	return 0;
+}
+
+/* -----------------------------------------------------------------------------
+ * V4L2 Subdevice Operations
+ */
+ 
+static int mt9m114_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
+{
+	struct mt9m114 *mt9m114 = to_mt9m114(sd);
+	struct v4l2_mbus_framefmt *format;
+	/* Initialize with default formats */
+	// Use source pad format
+	format = v4l2_subdev_get_try_format(sd, fh->pad, 0);
+	*format = mt9m114->default_format;
+
+	return 0;
+}
+
+static int mt9m114_close(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
+{
+	return 0;
+}
+
+static const struct v4l2_subdev_internal_ops mt9m114_internal_ops = {
+	.open		= mt9m114_open,
+	.close		= mt9m114_close,
+}; 
+
+static const struct v4l2_subdev_pad_ops mt9m114_pad_ops = {
+	.get_fmt		= mt9m114_g_mbus_fmt,
+	.set_fmt		= mt9m114_s_mbus_fmt,
+};
+
+static const struct v4l2_subdev_video_ops mt9m114_video_ops = {
+	.s_parm = mt9m114_s_parm,
+	.g_parm = mt9m114_g_parm,
+	.g_frame_interval = mt9m114_g_frame_interval,
+	.s_frame_interval = mt9m114_s_frame_interval,
+	.s_stream = mt9m114_s_stream,
+};
+
+static const struct v4l2_subdev_ops mt9m114_ops = {
+	.pad	= &mt9m114_pad_ops,
+	.video 	= &mt9m114_video_ops,
+};
+
+/* -----------------------------------------------------------------------------
+ * Media Operations
+ */
+
+static const struct media_entity_operations mt9m114_media_ops = {
+	.link_validate = v4l2_subdev_link_validate,
+};
+
+/* -----------------------------------------------------------------------------
+ * GPIO operations
+ */
+static int mt9m114_configure_gpios(struct mt9m114 *sensor)
+{
+	static const char * const gpio_names[] = {
+		"nreset-gpios", "nled-gpios"
+	};
+
+	struct mt9m114_gpio *g = sensor->gpio;
+	int ret, i;
+
+	for (i = 0; i < MAX_GPIO_NUM; i++) {
+		unsigned int flags = GPIOF_DIR_OUT;
+
+		if (!gpio_is_valid(g[i].gpio)){
+			printk("%s: %s invalid\n", __func__, gpio_names[i]);
+			return -EINVAL;
+		}
+
+		if (g[i].level)
+			flags |= GPIOF_INIT_LOW; // deassert
+		else{
+			flags |= GPIOF_INIT_HIGH; // deassert
+		}
+
+		ret = devm_gpio_request_one(sensor->dev, g[i].gpio, flags, gpio_names[i]);
+		if (ret) {
+			return ret;
+		}
+	}
+
+	mdelay(10);
+	return 0;
+} 
+ 
+static int mt9m114_gpio_set_value(struct mt9m114 *sensor, int id, u32 val)
+{
+	if (!gpio_is_valid(sensor->gpio[id].gpio)){
+		return 0;
+	}
+	gpio_set_value(sensor->gpio[id].gpio, val);
+	sensor->gpio_state[id] = val;
+	return 1;
+}
+
+int mt9m114_gpio_assert(struct mt9m114 *sensor, int id)
+{
+	return mt9m114_gpio_set_value(sensor, id, sensor->gpio[id].level);
+}
+
+int mt9m114_gpio_deassert(struct mt9m114 *sensor, int id)
+{
+	int value = (sensor->gpio[id].level) ? 0:1;
+	return mt9m114_gpio_set_value(sensor, id, value);
+}
+
+/* -----------------------------------------------------------------------------
+ * Platform Device Driver
+ */
+
+static const struct mt9m114_video_format *mt9m114_parse_video_format(struct device_node *node)
+{
+	const char *pattern = "mono";
+	unsigned int vf_code;
+	unsigned int i;
+	u32 width;
+	int ret;
+
+	ret = of_property_read_u32(node, "xlnx,video-format", &vf_code);
+	if (ret < 0)
+		return ERR_PTR(ret);
+
+	ret = of_property_read_u32(node, "xlnx,video-width", &width);
+	if (ret < 0)
+		return ERR_PTR(ret);
+
+	if (vf_code == XVIP_VF_MONO_SENSOR)
+		of_property_read_string(node, "xlnx,cfa-pattern", &pattern);
+
+	for (i = 0; i < ARRAY_SIZE(mt9m114_supported_video_formats); ++i) {
+		const struct mt9m114_video_format *format = &mt9m114_supported_video_formats[i];
+
+		if (format->vf_code != vf_code || format->width != width)
+			continue;
+
+		if (vf_code == XVIP_VF_MONO_SENSOR &&
+		    strcmp(pattern, format->pattern))
+			continue;
+
+		return format;
+	}
+
+	return ERR_PTR(-EINVAL);
+}
+
+static int mt9m114_parse_gpio(struct mt9m114 *sensor)
+{
+	static const char * const prop_names[] = {
+		"nreset-gpios", "nled-gpios"
+	};
+
+	struct i2c_client *client = sensor->client;
+	struct device_node *node = client->dev.of_node;
+	int ret, i;
+
+	for (i = 0; i < MAX_GPIO_NUM; i++) {
+		enum of_gpio_flags of_flags;
+		ret = of_get_named_gpio_flags(node, prop_names[i], 0, &of_flags);
+		if (ret < 0) {
+			v4l_err(client, "failed to parse %s DT property\n", prop_names[i]);
+			sensor->gpio[i].gpio = ret;
+			printk("%s: optional %s invalid\n", __func__, prop_names[i]);
+			return -EINVAL;
+		}
+
+		sensor->gpio[i].gpio = ret;
+		sensor->gpio[i].level = (of_flags & OF_GPIO_ACTIVE_LOW) ? 0:1;
+	
+		v4l_info(client, "%s of_flags 0x%x level 0x%x index %d\n", prop_names[i], of_flags, sensor->gpio[i].level, i);
+	}
+	return 0;
+}
+
+static int mt9m114_parse_dt(struct v4l2_subdev *sd)
+{
+	struct mt9m114 *sensor = to_mt9m114(sd); 
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct device_node *node = client->dev.of_node;
+	struct device_node *ports;
+	struct device_node *port;
+	unsigned int nports = 0;
+	int ep_num = 0;
+
+	if (!node) {
+		return -EINVAL;
+	}
+
+	ports = of_get_child_by_name(node, "ports");
+	if (ports == NULL)
+		ports = node;
+
+	for_each_child_of_node(ports, port) {
+		const struct mt9m114_video_format *format;
+		struct device_node *endpoint;
+
+		if (!port->name || of_node_cmp(port->name, "port"))
+			continue;
+
+		format = mt9m114_parse_video_format(port);
+		if (IS_ERR(format)) {
+			v4l_err(client, "invalid format in DT");
+			return PTR_ERR(format);
+		}
+
+		/* Get and check the format description */
+		if (!sensor->vid_format) {
+			sensor->vid_format = format;
+		} else {
+			v4l_err(client, "Support single pad only");
+			return -EINVAL;
+		}
+
+		endpoint = of_get_next_child(port, NULL);
+		if (endpoint){
+			ep_num++;
+			of_node_put(endpoint);
+		}
+
+		/* Count the number of ports. */
+		nports++;
+	}
+
+	if (nports != 1 && ep_num != 1) {
+		v4l_err(client, "invalid number of ports %u / endpoints %d\n", nports, ep_num);
+		return -EINVAL;
+	}
+
+	sensor->npads = nports;
+
+	return 0;
+}
+
+static int mt9m114_probe(struct i2c_client *client,
+			const struct i2c_device_id *id)
+{
+	struct mt9m114 *sensor;
+	struct v4l2_subdev *sd;
+	struct v4l2_ctrl_handler *hdl;
+	u16 chip_id, command, output_control;
+	//struct v4l2_mbus_framefmt default_fmt;
+	int ret;
+
+	/* Check if the adapter supports the needed features */
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C))
+		return -EIO;
+	
+	sensor = kzalloc(sizeof(*sensor), GFP_KERNEL);
+	if (sensor == NULL)
+		return -ENOMEM;
+	sensor->dev = &client->dev;
+	sensor->client = client;
+	
+	/// GPIO (debugging only)
+	mt9m114_parse_gpio(sensor);
+	mt9m114_configure_gpios(sensor);
+	
+	mt9m114_gpio_deassert(sensor, 0); // nreset
+	mdelay(50);
+	mt9m114_gpio_assert(sensor, 0); // nreset
+	mdelay(50);
+	mt9m114_gpio_deassert(sensor, 0); // nreset
+	mdelay(50);
+	mt9m114_gpio_assert(sensor, 1); // nled, turn on
+
+	/// Check Chip ID
+	ret = mt9m114_read16(client, MT9M114_CHIP_ID, &chip_id);
+	if (ret < 0) {
+		v4l_err(client, "Failed to get chip id\n");
+		return -ENODEV;
+	}
+	
+	if (chip_id != 0x2481) {
+		v4l_err(client, "chip id 0x%04x mismatch\n", chip_id);
+		return -ENODEV;
+	}
+
+#if 0	
+	/* Reset the sensor */
+	ret = mt9m114_write16(client, MT9M114_SOFT_RESET, 0x0001);
+	if (ret < 0) {
+		v4l_err(client, "Failed to reset the sensor\n");
+		return ret;
+	}
+	mt9m114_write16(client, MT9M114_SOFT_RESET, 0x0000);
+	mdelay(50);
+
+	do {
+		ret = mt9m114_read16(client, MT9M114_COMMAND_REGISTER, &command);
+		if (ret < 0)
+			return ret;
+	} while (command & MT9M114_COMMAND_REGISTER_SET_STATE);
+	
+	ret = mt9m114_writeregs(client, mt9m114_init, ARRAY_SIZE(mt9m114_init));
+	if (ret < 0) {
+		v4l_err(client, "Failed to initialize the sensor\n");
+		return ret;
+	}
+#endif
+	
+	//// New code //////////
+	mt9m114_reset(client, 0);
+	mt9m114_PLL_settings(client);
+	
+	ret = mt9m114_writeregs(client, mt9m114_init, ARRAY_SIZE(mt9m114_init));
+	if (ret < 0) {
+		v4l_err(client, "Failed to initialize the sensor\n");
+		return ret;
+	}
+	
+	mt9m114_sensor_optimization(client);
+	
+	mt9m114_errata_1(client);
+	mt9m114_errata_2(client);
+	mt9m114_write_array(client, pga_regs);
+	mt9m114_write_array(client, ccm_awb_regs);
+	mt9m114_CPIPE_preference(client);
+	//mt9m114_patch2_black_lvl_correction_fix(client);
+	//mt9m114_patch3_adaptive_sensitivity(client);
+	///
+
+	mt9m114_set_state(client, MT9M114_SYS_STATE_ENTER_CONFIG_CHANGE);	
+	v4l_info(client, "chip found @ 0x%02x (%s)\n", client->addr << 1, client->adapter->name);
+	
+	/* Initialize V4L2 subdevice */
+	sd = &sensor->sd;
+	v4l2_i2c_subdev_init(sd, client, &mt9m114_ops);	
+	
+	/* Parse dt */
+	if(mt9m114_parse_dt(sd) < 0){
+		ret = -EFAULT;
+		goto err1;
+	}
+	
+	/* Initialize V4L2 subdevice and media entity
+	 * Should only have SOURCE pad
+	 */
+	sensor->pads[SOURCE_PAD].flags = MEDIA_PAD_FL_SOURCE;
+
+	/* Initialize the default format */
+	sensor->default_format.code = sensor->vid_format->mbus_code;
+	sensor->default_format.field = V4L2_FIELD_NONE;
+	sensor->default_format.colorspace = V4L2_COLORSPACE_SRGB;
+	sensor->default_format.width = mt9m114_resolutions[MT9M114_720P].width;
+	sensor->default_format.height = mt9m114_resolutions[MT9M114_720P].height;
+	sensor->formats[SOURCE_PAD] = sensor->default_format;
+	
+	/* Initialize V4L2 media entity */
+	strcpy(sd->name, DRIVER_NAME); // Will use this name in the video pipeline driver
+	sd->internal_ops = &mt9m114_internal_ops;
+	sd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+	sd->entity.ops = &mt9m114_media_ops;
+	ret = media_entity_pads_init(&sd->entity, sensor->npads, sensor->pads);
+	if (ret < 0){
+		goto err1;
+	}
+	
+	/*
+	 * Initialize hardware controls
+	 */
+	hdl = &sensor->hdl;
+	v4l2_ctrl_handler_init(hdl, 8);
+	v4l2_ctrl_new_std(hdl, &mt9m114_ctrl_ops, V4L2_CID_HFLIP, 0, 1, 1, 0);
+	v4l2_ctrl_new_std(hdl, &mt9m114_ctrl_ops, V4L2_CID_VFLIP, 0, 1, 1, 0);
+	v4l2_ctrl_new_std(hdl, &mt9m114_ctrl_ops, V4L2_CID_BRIGHTNESS, 0, 255, 1, 80);
+	v4l2_ctrl_new_std(hdl, &mt9m114_ctrl_ops, V4L2_CID_AUTO_WHITE_BALANCE, 0, 1, 1, 0);
+	v4l2_ctrl_new_std(hdl, &mt9m114_ctrl_ops, V4L2_CID_WHITE_BALANCE_TEMPERATURE, 2700, 6500, 100, 6500);
+	v4l2_ctrl_new_std_menu(hdl, &mt9m114_ctrl_ops, V4L2_CID_EXPOSURE_AUTO, 1, 0, /*V4L2_EXPOSURE_AUTO*/V4L2_EXPOSURE_MANUAL);
+	v4l2_ctrl_new_std(hdl, &mt9m114_ctrl_ops, V4L2_CID_GAIN, 0, 512, 1, 32);
+	v4l2_ctrl_new_std(hdl, &mt9m114_ctrl_ops, V4L2_CID_EXPOSURE, 0, 512, 5, 32);
+	v4l2_ctrl_new_std(hdl, &mt9m114_ctrl_ops, V4L2_CID_SATURATION, 0, 255, 1, 128);
+	v4l2_ctrl_new_std(hdl, &mt9m114_ctrl_ops, V4L2_CID_SHARPNESS, -7, 7, 1, 7);
+	v4l2_ctrl_new_std(hdl, &mt9m114_ctrl_ops, V4L2_CID_CONTRAST, 16, 64, 1, 32);
+	
+	/* hook the control handler into the driver */
+	sd->ctrl_handler = hdl;
+	if (hdl->error) {
+		ret = hdl->error;
+		goto err2;
+	}
+	ret = v4l2_ctrl_handler_setup(hdl);
+	if (ret) {
+		goto err2;
+	}
+	ret = v4l2_async_register_subdev(sd);
+	if (ret < 0){
+		goto err2;
+	}
+
+	return 0;
+
+err2:
+	v4l2_ctrl_handler_free(hdl);
+	media_entity_cleanup(&sd->entity);
+err1:
+	kfree(sensor);
+	return ret;
+}
+
+static int mt9m114_remove(struct i2c_client *client)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct mt9m114 *sensor = to_mt9m114(sd);
+
+	v4l2_device_unregister_subdev(sd);
+	v4l2_ctrl_handler_free(sd->ctrl_handler);
+	kfree(sensor);
+	return 0;
+}
+
+static const struct i2c_device_id mt9m114_id[] = {
+	{DRIVER_NAME, 0},
+	{},
+};
+
+MODULE_DEVICE_TABLE(i2c, mt9m114_id);
+
+static struct i2c_driver mt9m114_driver = {
+	.driver = {
+		.owner  = THIS_MODULE,
+		.name   = DRIVER_NAME,
+	},
+	.probe          = mt9m114_probe,
+	.remove         = mt9m114_remove,
+	.id_table       = mt9m114_id,
+};
+
+module_i2c_driver(mt9m114_driver);
+
+MODULE_DESCRIPTION("Aptina MT9M114 sensor driver");
+MODULE_AUTHOR("Watson Chow <watson.chow@avnet.com>");
+MODULE_LICENSE("GPL v2");
\ No newline at end of file
